[{
  "_id": {
    "$oid": "5f3105f165b12f27485ce7e9"
  },
  "createdAt": {
    "$date": "2020-08-28T03:08:47.835Z"
  },
  "title": "공부한거 마크다운 js_web",
  "user": "tamd5971@naver.com",
  "markdown": "목차\r\n==================\r\n1. [자바스크립트 소개](#N1)\r\n2. [HTML에서 JavaScript 로드](#N2)\r\n3. [Browser Object Model](#N3)\r\n4. [Document Object Model](#N4)\r\n5. [Text](#N5)\r\n6. [문서의 기하학적 특성](#N6)\r\n7. [이벤트](#N7)\r\n8. [jQuery 이벤트](#N8)\r\n9. [네트워크 통신](#N9)\r\n\r\n\r\n자바스크립트 소개<a id=\"N1\"></a>\r\n------------------\r\n+ html: 정보\r\n+ css: 디자인\r\n+ JavaScript: 웹브라우저, html 제어\r\n\r\n\r\n\r\nHTML에서 JavaScript 로드<a id=\"N2\"></a>\r\n----------------------------------\r\n### 1. inline 방식\r\n+ 태그에 자바스크립트를 직접 기술\r\n+ `<input type=\"button\" onclick=\"alert('Hello world')\" value=\"Hello world\" />`\r\n+ onclick을 소지하고 있는 버튼을 클릭했을 때 onclick의 \"\"안에 들어있는 js코드 실행(이벤트)\r\n+ 장점: 태그에 연관된 스크립트가 분명하게 드러난다.\r\n+ 단점: 정보와 제어가 섞여있기 때문에 정보로서의 가치가 떨어짐, 유지보수가 쉽지 않다\r\n\r\n\r\n### 2. script 태그의 이용\r\n+ `<script>js 코드로 해석</script>`: script 태그까지가 html 문법\r\n+ 유지보수를 하기에 좋고 정보와 제어를 구분한다는 점에서 바람직함\r\n\r\n\r\n### 3. 외부파일 로드\r\n+ `<script src=\"./script.js\"></script>`\r\n+ 보통 body 태그의 마지막에 넣는다\r\n+ 불러와서 사용한다는 점에서 중복을 제거할 수 있고 유지보수의 편의성을 가지고 있다\r\n\r\n\r\n\r\n### 4. onload\r\n+ 스크립트 파일의 위치를 헤드 태그 안으로 옮기면 오류가 날 수 있다\r\n    + ID를 불러왔을 때 아직 body의 엘리먼트가 생성 되지 않았기 때문에 NULL값이 들어감\r\n    + window.onload = function(){ script 태그 안의 코드 }로 해결\r\n    + 웹페이지의 모든 코드가 다읽히고 완성이되면 웹브라우저는 window객체의 onload 메소드를 호출하기 때문에 안의 함수가 실행됨\r\n\r\n\r\n\r\n\r\nBrowser Object Model<a id=\"N3\"></a>\r\n-----------------------------\r\n+ 웹브라우저를 제어하기 위해서 브라우저가 제공해주는 객체들\r\n+ js를 통해서 새창 열기, 현재창의 URL알아내기 등\r\n+ [BOM](https://github.com/JeongYunMi/web_Study/wiki/JS_WEB_BOM)\r\n \r\n\r\n\r\nDocument Object Model<a id=\"N4\"></a>\r\n-----------------------------\r\n+ [DOM](https://github.com/JeongYunMi/web_Study/wiki/JS_WEB_DOM)\r\n\r\n\r\nText 객체<a id=\"N5\"></a>\r\n------------------\r\n![텍스트객체](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2257.png)\r\n생활코딩-택스트객체\r\n+ 텍스트 객체는 텍스트 노드에 대한 DOM 객체로 CharcterData를 상속 받는다.\r\n+ DOM에서는 공백이나 줄바꿈도 텍스트 노드 \r\n```html\r\n<p id=\"target1\"><span>Hello world</span></p>\r\n<p id=\"target2\">\r\n    <span>Hello world</span>\r\n</p>\r\n<script>\r\nvar t1 = document.getElementById('target1').firstChild; //결과는 <span>\r\nvar t2 = document.getElementById('target2').firstChild; //결과는 공백\r\n \r\nconsole.log(t1.firstChild.nodeValue); //Hello world출력\r\ntry{\r\n    console.log(t2.firstChild.nodeValue);   //없어서 에러\r\n} catch(e){\r\n    console.log(e);\r\n}\r\nconsole.log(t2.nextSibling.firstChild.nodeValue); //Hello world출력\r\n \r\n</script>\r\n### 1. 값 API\r\n    + nodeValue\r\n    + data\r\n```html\r\n<ul>\r\n    <li id=\"target\">html</li> \r\n    <li>css</li>\r\n    <li>JavaScript</li>\r\n</ul>\r\n<script>// document.getElementById('target') = <li id=\"target\">\r\n    var t = document.getElementById('target').firstChild;  //.firstChild = html 이라는 텍스트노드\r\n    console.log(t.nodeValue);\r\n    console.log(t.data);\r\n</script>\r\n```\r\n### 2. 조작 API\r\n    + appendData(textnode.value(추가해줄 값)): 교체해줄 값을 뒤에 추가\r\n    + deleteData(시작, 끝): 시작 위치의 다음부터 끝 숫자까지 위치의 값 삭제 (공백도 카운트)\r\n    + insertData(시작, textnode.value(추가해줄 값)): 기존 데이터에 시작위치부터 추가해줄 값을 사이에 삽입  \r\n    + replaceData(시작, 끝, textnode.value(추가해줄 값)): 시작에서 끝까지를 카운팅하여 그부분을 추가해줄 값으로 대체\r\n        + 기존 문장: Cording everybody!\r\n        + replaceData(5,5,JavaScript);\r\n        + 바뀐 문장: Cordi(JavaScript)erbody!\r\n    + substringData(시작, 끝): 정보 중에 일부의 정보 가공할 때 사용\r\n        + `alert(target.substringData(start.value, end.value));`: target의 시작에서 끝 부분까지를 리턴\r\n\r\n    + 형식> textNode.조작API(~~);\r\n\r\n\r\n\r\n문서의 기하학적 특성<a id=\"N6\"></a>\r\n------------------\r\n### 1. 엘리먼트의 위치와 크기\r\n![엘리먼트의 크기나 위치 알아내기](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2402.png)\r\n+ `console.log(t.getBoundingClientRect());`: t는 coding이라는 텍스트 노드를 가진 div태그\r\n![결과](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2403.png)\r\n+ viewport의 좌표를 사용한다\r\n+ 위 결과에서 coding에서 파란선까지는 패딩, 파란선은 테두리, 파란선부터 끝부분까지는 마진이다\r\n+ width는 마진값은 포함이 안된다\r\n+ IE에서는 width와 height값을 제공하지 않는다\r\n+ 중첩된 엘리먼트(해당 엘리먼트와 body 사이에 어떤 엘리먼트가 있던간에 body를 기준으로 하여 계산한다)\r\n    + t.offsetParent를 사용하여 측정의 기준이되는 엘리먼트를 찾을 수 있다.\r\n    + 만약 부모 중 CSS position의 값이 static인 td, th, table 엘리먼트가 있다면 이 엘리먼트가 offsetParent가 된다\r\n![중첩 엘리먼트](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2404.png)\r\n![중첩 엘리먼트 결과](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2406.png)\r\n\r\n\r\n### 2. 뷰포트\r\n+ 스크롤이 존재하는 페이지에서 사용자가 한 번에 볼 수 있는 영역\r\n```html\r\n <style>\r\n    body{\r\n        padding:0;\r\n        margin:0;\r\n    }\r\n    div{\r\n        border:50px solid #1065e6;\r\n        padding:50px;\r\n        margin:50px;\r\n    }\r\n    #target{\r\n        width:100px;\r\n        height:2000px;\r\n    }\r\n</style>\r\n    <div>\r\n        <div id=\"target\">\r\n            Coding\r\n        </div>\r\n    </div>\r\n \r\n<script> //setInterval(함수, 숫자(1000이 1초)): 1초마다 함수를 반복호출\r\nvar t = document.getElementById('target');\r\nsetInterval(function(){\r\n    console.log('getBoundingClientRect : ', t.getBoundingClientRect().top, 'pageYOffset:', window.pageYOffset);\r\n}, 1000) //window.pageYOffset: 스크롤한 크기 40으로 나올경우 40픽셀만큼 스크롤했음을 의미\r\n</script>\r\n```\r\n\r\n\r\n### 3. 스크롤제어\r\n+ window.scrollTo(0, 1000);\r\n+ 0 = x, 1000= y 1000만큼의 스크롤 이동\r\n\r\n\r\n### 4. 스크린의 크기\r\n```javascript\r\nconsole.log('window.innerWidth:', window.innerWidth, 'window.innerHeight:', window.innerHeight);\r\nconsole.log('screen.width:', screen.width, 'screen.height:', screen.height);\r\n```\r\n+ window.innerWidth, window.innerHeight : inner로 시작하는 API는 뷰포트상의 크기\r\n+ screen.width, screen.height: 사용하고 있는 모니터 해상도의 크기\r\n\r\n\r\n이벤트 <a id=\"N7\"></a>\r\n----------------\r\n+ [이벤트](https://github.com/JeongYunMi/web_Study/wiki/JS_Event)\r\n\r\n\r\njQuery 이벤트<a id=\"N8\"></a>\r\n------------------\r\n+ 크로스 브라우징을 알아서 해결\r\n+ 보다 적은 코드로 이벤트 구현 가능\r\n```html\r\n<input type=\"button\" id=\"pure\" value=\"pure\" />\r\n<input type=\"button\" id=\"jquery\" value=\"jQuery\" />\r\n<script src=\"//code.jquery.com/jquery-1.11.0.min.js\"></script>\r\n<script>\r\n    // 순수하게 구현했을 때\r\n    var target = document.getElementById('pure');\r\n    if(target.addEventListener){\r\n        target.addEventListener('click', function(event){\r\n            alert('pure');\r\n        });\r\n    } else { //기능테스트 조건문\r\n        target.attachEvent('onclick', function(event){\r\n            alert('pure');\r\n        });\r\n    }\r\n \r\n    // jQuery를 사용했을 때\r\n    $('#jquery').on('click', function(event){//on API\r\n        alert('jQuery');\r\n    })\r\n</script>\r\n```\r\n+ on API\r\n    + .on( events [, selector ] [, data ], handler(eventObject) )\r\n    + event : 등록하고자 하는 이벤트 타입을 지정한다. (예: \"click\")\r\n    + selector : 이벤트가 설치된 엘리먼트의 하위 엘리먼트를 이벤트 대상으로 필터링함\r\n    + data : 이벤트가 실행될 때 핸들러로 전달될 데이터를 설정함\r\n    + handler : 이벤트 핸들러 함수\r\n\r\n+ on API- 필터링\r\n```html\r\n<ul>\r\n    <li><a href=\"#\">HTML</a></li>\r\n    <li><a href=\"#\">CSS</a></li>\r\n    <li><a href=\"#\">JavaScript</a></li>\r\n</ul>\r\n<script  src=\"http://code.jquery.com/jquery-latest.min.js\"></script>\r\n<script>                                         //selector \r\n    $('ul').on('click','a, li', function(event){ //ul태그 하위의 a태그와 li태그가 선택되었을 때로 필터링\r\n        console.log(this.tagName); //a와 li중 클릭된 태그 출력\r\n    })\r\n</script>\r\n```\r\n    + late binding\r\n```html\r\n<script src=\"//code.jquery.com/jquery-1.11.0.min.js\"></script>\r\n<script>\r\n    $('body').on('click','a, li', function(event){\r\n        console.log(this.tagName);\r\n    })\r\n</script>\r\n<ul>\r\n    <li><a href=\"#\">HTML</a></li>\r\n    <li><a href=\"#\">CSS</a></li>\r\n    <li><a href=\"#\">JavaScript</a></li>\r\n</ul>\r\n```\r\n+ `$('ul').on('click','a, li', function(event)`과 같이 존재하지 않는 태그에 대해서는 이벤트를 달 수 없으나 $('body').on('click','a, li', function(event)라고 하면 존재하지 않는 태그에 대해서도 이벤트를 달 수 있다.\r\n\r\n\r\n    + 다중 바인딩\r\n        + 하나의 엘리먼트에 여러개의 이벤트 타입을 동시에 등록 가능\r\n```javascript\r\n$('#target').on('focus blur', function(e){ //focus와 blur과 같이 같은 이벤트에 동일한 이벤트 설치\r\n    $('#status').html(e.type);\r\n})\r\n/*\r\nvar handler = function(e){\r\n   $(#status).html(e.type);\r\n}\r\n$('#target').on('focus', handler).on('blur',handler);\r\n로도 사용가능*/\r\n```\r\n\r\n\r\n    + 이벤트 제거\r\n```javascript\r\n<input type=\"text\" id=\"target\"></textarea>\r\n<input id=\"remove\"  type=\"button\" value=\"remove\" />\r\n<p id=\"status\"></p>\r\n<script src=\"//code.jquery.com/jquery-1.11.0.min.js\"></script>\r\n<script>\r\n  var handler = function(e){\r\n    $('#status').text(e.type+Math.random());\r\n  };\r\n  $('#target').on('focus blur', handler)\r\n  $('#remove').on('click' , function(e){\r\n    $('#target').off('focus blur', handler); //몇개의 이벤트가 등록되어있던 한 방에 정리\r\n    console.log(32);\r\n  })\r\n</script>\r\n```\r\n\r\n\r\n\r\n네트워크 통신 <a id=\"N9\"></a>\r\n------------------\r\n+ 자바 스크립트를 이용해서 내부적으로 통신을 할 수 있는 방법\r\n\r\n### 1. Ajax(Asynchronous JavaScript and XML)\r\n+ 비동기적 자바스크립트와 XML\r\n+ 자바 스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 주고받는 방식\r\n+ 사용하는 API: XMLHttpRequest\r\n```javascript\r\n<p>time : <span id=\"time\"></span></p>\r\n<input type=\"button\" id=\"execute\" value=\"execute\" />\r\n<script>\r\ndocument.querySelector('input').addEventListener('click', function(event){\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('GET', './time.php'); //get방식으로 time.php와 통신하겠다\r\n    xhr.onreadystatechange = function(){ //통신하며 상태가 변할 때마다 onreadystatechange호출\r\n        if(xhr.readyState === 4 && xhr.status === 200){ //통신이 완료했고 성공했을 경우\r\n            document.querySelector('#time').innerHTML = xhr.responseText; //서버에서 받아온 값을 넣어주겠다.\r\n        }\r\n    }\r\n    xhr.send(); //send가 호출될 때 xhr.open('GET', './time.php');로 통신을 시작\r\n}); \r\n</script> \r\n```\r\n+ post방식\r\n```html\r\n<p>time : <span id=\"time\"></span></p>\r\n<select id=\"timezone\">\r\n    <option value=\"Asia/Seoul\">asia/seoul</option>\r\n    <option value=\"America/New_York\">America/New_York</option>\r\n</select>\r\n<select id=\"format\">\r\n    <option value=\"Y-m-d H:i:s\">Y-m-d H:i:s</option>\r\n    <option value=\"Y-m-d\">Y-m-d</option>\r\n</select>\r\n<input type=\"button\" id=\"execute\" value=\"execute\" />\r\n<script>\r\ndocument.querySelector('input').addEventListener('click', function(event){\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('POST', './time2.php');\r\n    xhr.onreadystatechange = function(){\r\n        document.querySelector('#time').innerHTML = xhr.responseText;\r\n    }\r\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n    var data = '';\r\n    data += 'timezone='+document.getElementById('timezone').value;\r\n    data += '&format='+document.getElementById('format').value;\r\n    xhr.send(data); \r\n});\r\n</script> \r\n```\r\n    + timezone=Asia/Seoul&format=Y=m-d\r\n    + 값과 값 구분 &\r\n    + 값의 이름과 값의 내용 =\r\n\r\n\r\n### 2. JSON(JavaScript Object Notation)\r\n+ 자바 스크립트에서 객체를 만들 때 사용하는 표현식\r\n    + `var person = {\"height\":174, \"job\":\"programmer\"}` - 객체\r\n    + `var member = [\"height\", \"job\",\"programmer\"]` - 배열\r\n    + 배열이나 객체 상태 그대로 보낼 수 있는 방식이 없다\r\n    + 이러한 불편을 해소하기 위해 만든 규칙 json\r\n    + 줄바꿈시 \\처리\r\n+ API\r\n    + JSON.parse(): 인자로 전달된 문사열을 자바스크립트의 데이터로 변환한다.\r\n```\r\n> var info = '{\\\r\n   \"font_face\" : \"iconsolata\",\\\r\n   \"font_size\": 30,\\\r\n   \"ignored_packages\":\\\r\n   [\\\r\n   ],\\\r\n   \"line_numbers\": false\\\r\n}'\r\n\r\n> info\r\n\"{ \"font_face\" : \"iconsolata\", \"font_size\": 30, \"ignored_packages\": [  ], \"line_numbers\": false}\"\r\n\r\n> var infoobj = JSON.parse(info);\r\n{font_face: \"iconsolata\", font_size: 30, ignored_packages: Array(0), line_numbers: false}\r\n```\r\n\r\n    + JSON.stringify(): 인자로 전달된 자바스크립트의 데이터를 문자열로 변환한다.\r\n\r\n\r\n### 3. JSON 포맷을 이용한 Ajax 통신\r\n```\r\n<?php\r\n$timezones = [\"Asia/Seoul\", \"America/New_York\"];\r\nheader('Content-Type: application/json');\r\necho json_encode($timezones);//php데이터를 json 형식으로 전환\r\n?> //결과: [\"Asia\\/Seoul\",\"America\\/New_York\"]\r\n```\r\n```html\r\n<p id=\"timezones\"></p>\r\n<input type=\"button\" id=\"execute\" value=\"execute\" />\r\n<script>\r\ndocument.querySelector('input').addEventListener('click', function(event){\r\nvar xhr = new XMLHttpRequest();\r\nxhr.open('GET', './time2.php');\r\nxhr.onreadystatechange = function(){\r\nif(xhr.readyState === 4 && xhr.status === 200){\r\nvar _tzs = xhr.responseText;\r\nvar tzs = JSON.parse(_tzs); // 서버에서 전송한 json 데이터를 자바스크립트 배열로 전환\r\nvar _str = '';\r\nfor(var i = 0; i< tzs.length; i++){\r\n_str += '<li>'+tzs[i]+'</li>';\r\n}\r\n_str = '<ul>'+_str+'</ul>';\r\n \r\n  document.querySelector('#timezones').innerHTML = _str;\r\n      }\r\n   }\r\nxhr.send(); \r\n}); \r\n</script> \r\n```\r\n\r\n\r\n### 4. jQuery Ajax 통신\r\n+ jOuery를 이용하여 Ajax를 사용하게 되면 크로스 브라우징 이슈가 제이쿼리에 의해 해결된다\r\n+ 여러가지 편리한 가능 제공\r\n+ [jQuery Ajax API](https://api.jquery.com/category/ajax/)\r\n+ jQuery.ajax( url [, settings ] )\r\n    + $.ajax(url, settings)\r\n    + data: 서버로 데이터를 전송할 때 이 옵션을 사용한다.\r\n    + dataType: 서버측에서 전송한 데이터를 어떤 형식의 데이터로 해석할 것인가를 지정한다. 값으로 올 수 있는 것은 xml, json, script, html이다. 형식을 지정하지 않으면 jQuery가 알아서 판단한다.\r\n    + success: 성공했을 때 호출할 콜백을 지정한다. Function( PlainObject data, String textStatus, jqXHR jqXHR )\r\n    + type: 데이터를 전송하는 방법을 지정한다. get, post를 사용할 수 있다.\r\n",
  "makrdownHtml": "<h1>목차</h1>\n<ol>\n<li><a href=\"#N1\">자바스크립트 소개</a></li>\n<li><a href=\"#N2\">HTML에서 JavaScript 로드</a></li>\n<li><a href=\"#N3\">Browser Object Model</a></li>\n<li><a href=\"#N4\">Document Object Model</a></li>\n<li><a href=\"#N5\">Text</a></li>\n<li><a href=\"#N6\">문서의 기하학적 특성</a></li>\n<li><a href=\"#N7\">이벤트</a></li>\n<li><a href=\"#N8\">jQuery 이벤트</a></li>\n<li><a href=\"#N9\">네트워크 통신</a></li>\n</ol>\n<h2>자바스크립트 소개<a id=\"N1\"></a></h2>\n<ul>\n<li>html: 정보</li>\n<li>css: 디자인</li>\n<li>JavaScript: 웹브라우저, html 제어</li>\n</ul>\n<h2>HTML에서 JavaScript 로드<a id=\"N2\"></a></h2>\n<h3>1. inline 방식</h3>\n<ul>\n<li>태그에 자바스크립트를 직접 기술</li>\n<li><code>&lt;input type=&quot;button&quot; onclick=&quot;alert('Hello world')&quot; value=&quot;Hello world&quot; /&gt;</code></li>\n<li>onclick을 소지하고 있는 버튼을 클릭했을 때 onclick의 &quot;&quot;안에 들어있는 js코드 실행(이벤트)</li>\n<li>장점: 태그에 연관된 스크립트가 분명하게 드러난다.</li>\n<li>단점: 정보와 제어가 섞여있기 때문에 정보로서의 가치가 떨어짐, 유지보수가 쉽지 않다</li>\n</ul>\n<h3>2. script 태그의 이용</h3>\n<ul>\n<li><code>&lt;script&gt;js 코드로 해석&lt;/script&gt;</code>: script 태그까지가 html 문법</li>\n<li>유지보수를 하기에 좋고 정보와 제어를 구분한다는 점에서 바람직함</li>\n</ul>\n<h3>3. 외부파일 로드</h3>\n<ul>\n<li><code>&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;</code></li>\n<li>보통 body 태그의 마지막에 넣는다</li>\n<li>불러와서 사용한다는 점에서 중복을 제거할 수 있고 유지보수의 편의성을 가지고 있다</li>\n</ul>\n<h3>4. onload</h3>\n<ul>\n<li>스크립트 파일의 위치를 헤드 태그 안으로 옮기면 오류가 날 수 있다\n<ul>\n<li>ID를 불러왔을 때 아직 body의 엘리먼트가 생성 되지 않았기 때문에 NULL값이 들어감</li>\n<li>window.onload = function(){ script 태그 안의 코드 }로 해결</li>\n<li>웹페이지의 모든 코드가 다읽히고 완성이되면 웹브라우저는 window객체의 onload 메소드를 호출하기 때문에 안의 함수가 실행됨</li>\n</ul>\n</li>\n</ul>\n<h2>Browser Object Model<a id=\"N3\"></a></h2>\n<ul>\n<li>웹브라우저를 제어하기 위해서 브라우저가 제공해주는 객체들</li>\n<li>js를 통해서 새창 열기, 현재창의 URL알아내기 등</li>\n<li><a href=\"https://github.com/JeongYunMi/web_Study/wiki/JS_WEB_BOM\">BOM</a></li>\n</ul>\n<h2>Document Object Model<a id=\"N4\"></a></h2>\n<ul>\n<li><a href=\"https://github.com/JeongYunMi/web_Study/wiki/JS_WEB_DOM\">DOM</a></li>\n</ul>\n<h2>Text 객체<a id=\"N5\"></a></h2>\n<p><img src=\"https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2257.png\" alt=\"텍스트객체\">\n생활코딩-택스트객체</p>\n<ul>\n<li>텍스트 객체는 텍스트 노드에 대한 DOM 객체로 CharcterData를 상속 받는다.</li>\n<li>DOM에서는 공백이나 줄바꿈도 텍스트 노드</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;target1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;target2&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">var</span> t1 = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;target1&#x27;</span>).firstChild; <span class=\"hljs-comment\">//결과는 &lt;span&gt;</span>\n<span class=\"hljs-keyword\">var</span> t2 = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;target2&#x27;</span>).firstChild; <span class=\"hljs-comment\">//결과는 공백</span>\n \n<span class=\"hljs-built_in\">console</span>.log(t1.firstChild.nodeValue); <span class=\"hljs-comment\">//Hello world출력</span>\n<span class=\"hljs-keyword\">try</span>{\n    <span class=\"hljs-built_in\">console</span>.log(t2.firstChild.nodeValue);   <span class=\"hljs-comment\">//없어서 에러</span>\n} <span class=\"hljs-keyword\">catch</span>(e){\n    <span class=\"hljs-built_in\">console</span>.log(e);\n}\n<span class=\"hljs-built_in\">console</span>.log(t2.nextSibling.firstChild.nodeValue); <span class=\"hljs-comment\">//Hello world출력</span>\n \n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n### 1. 값 API\n    + nodeValue\n    + data\n```html\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;target&quot;</span>&gt;</span>html<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span> \n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>css<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>JavaScript<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">// document.getElementById(&#x27;target&#x27;) = &lt;li id=&quot;target&quot;&gt;</span>\n    <span class=\"hljs-keyword\">var</span> t = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;target&#x27;</span>).firstChild;  <span class=\"hljs-comment\">//.firstChild = html 이라는 텍스트노드</span>\n    <span class=\"hljs-built_in\">console</span>.log(t.nodeValue);\n    <span class=\"hljs-built_in\">console</span>.log(t.data);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h3>2. 조작 API</h3>\n<pre><code>+ appendData(textnode.value(추가해줄 값)): 교체해줄 값을 뒤에 추가\n+ deleteData(시작, 끝): 시작 위치의 다음부터 끝 숫자까지 위치의 값 삭제 (공백도 카운트)\n+ insertData(시작, textnode.value(추가해줄 값)): 기존 데이터에 시작위치부터 추가해줄 값을 사이에 삽입  \n+ replaceData(시작, 끝, textnode.value(추가해줄 값)): 시작에서 끝까지를 카운팅하여 그부분을 추가해줄 값으로 대체\n    + 기존 문장: Cording everybody!\n    + replaceData(5,5,JavaScript);\n    + 바뀐 문장: Cordi(JavaScript)erbody!\n+ substringData(시작, 끝): 정보 중에 일부의 정보 가공할 때 사용\n    + `alert(target.substringData(start.value, end.value));`: target의 시작에서 끝 부분까지를 리턴\n\n+ 형식&gt; textNode.조작API(~~);\n</code></pre>\n<h2>문서의 기하학적 특성<a id=\"N6\"></a></h2>\n<h3>1. 엘리먼트의 위치와 크기</h3>\n<p><img src=\"https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2402.png\" alt=\"엘리먼트의 크기나 위치 알아내기\"></p>\n<ul>\n<li><code>console.log(t.getBoundingClientRect());</code>: t는 coding이라는 텍스트 노드를 가진 div태그\n<img src=\"https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2403.png\" alt=\"결과\"></li>\n<li>viewport의 좌표를 사용한다</li>\n<li>위 결과에서 coding에서 파란선까지는 패딩, 파란선은 테두리, 파란선부터 끝부분까지는 마진이다</li>\n<li>width는 마진값은 포함이 안된다</li>\n<li>IE에서는 width와 height값을 제공하지 않는다</li>\n<li>중첩된 엘리먼트(해당 엘리먼트와 body 사이에 어떤 엘리먼트가 있던간에 body를 기준으로 하여 계산한다)\n<ul>\n<li>t.offsetParent를 사용하여 측정의 기준이되는 엘리먼트를 찾을 수 있다.</li>\n<li>만약 부모 중 CSS position의 값이 static인 td, th, table 엘리먼트가 있다면 이 엘리먼트가 offsetParent가 된다\n<img src=\"https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2404.png\" alt=\"중첩 엘리먼트\">\n<img src=\"https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/904/2406.png\" alt=\"중첩 엘리먼트 결과\"></li>\n</ul>\n</li>\n</ul>\n<h3>2. 뷰포트</h3>\n<ul>\n<li>스크롤이 존재하는 페이지에서 사용자가 한 번에 볼 수 있는 영역</li>\n</ul>\n<pre class=\"hljs\"><code> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n    <span class=\"hljs-selector-tag\">body</span>{\n        <span class=\"hljs-attribute\">padding</span>:<span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-selector-tag\">div</span>{\n        <span class=\"hljs-attribute\">border</span>:<span class=\"hljs-number\">50px</span> solid <span class=\"hljs-number\">#1065e6</span>;\n        <span class=\"hljs-attribute\">padding</span>:<span class=\"hljs-number\">50px</span>;\n        <span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">50px</span>;\n    }\n    <span class=\"hljs-selector-id\">#target</span>{\n        <span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">100px</span>;\n        <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">2000px</span>;\n    }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;target&quot;</span>&gt;</span>\n            Coding\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"> <span class=\"hljs-comment\">//setInterval(함수, 숫자(1000이 1초)): 1초마다 함수를 반복호출</span>\n<span class=\"hljs-keyword\">var</span> t = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;target&#x27;</span>);\n<span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;getBoundingClientRect : &#x27;</span>, t.getBoundingClientRect().top, <span class=\"hljs-string\">&#x27;pageYOffset:&#x27;</span>, <span class=\"hljs-built_in\">window</span>.pageYOffset);\n}, <span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">//window.pageYOffset: 스크롤한 크기 40으로 나올경우 40픽셀만큼 스크롤했음을 의미</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h3>3. 스크롤제어</h3>\n<ul>\n<li>window.scrollTo(0, 1000);</li>\n<li>0 = x, 1000= y 1000만큼의 스크롤 이동</li>\n</ul>\n<h3>4. 스크린의 크기</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;window.innerWidth:&#x27;</span>, <span class=\"hljs-built_in\">window</span>.innerWidth, <span class=\"hljs-string\">&#x27;window.innerHeight:&#x27;</span>, <span class=\"hljs-built_in\">window</span>.innerHeight);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;screen.width:&#x27;</span>, screen.width, <span class=\"hljs-string\">&#x27;screen.height:&#x27;</span>, screen.height);\n</code></pre>\n<ul>\n<li>window.innerWidth, window.innerHeight : inner로 시작하는 API는 뷰포트상의 크기</li>\n<li>screen.width, screen.height: 사용하고 있는 모니터 해상도의 크기</li>\n</ul>\n<h2>이벤트 <a id=\"N7\"></a></h2>\n<ul>\n<li><a href=\"https://github.com/JeongYunMi/web_Study/wiki/JS_Event\">이벤트</a></li>\n</ul>\n<h2>jQuery 이벤트<a id=\"N8\"></a></h2>\n<ul>\n<li>크로스 브라우징을 알아서 해결</li>\n<li>보다 적은 코드로 이벤트 구현 가능</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;pure&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;pure&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;jquery&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;jQuery&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;//code.jquery.com/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-comment\">// 순수하게 구현했을 때</span>\n    <span class=\"hljs-keyword\">var</span> target = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;pure&#x27;</span>);\n    <span class=\"hljs-keyword\">if</span>(target.addEventListener){\n        target.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>{\n            alert(<span class=\"hljs-string\">&#x27;pure&#x27;</span>);\n        });\n    } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">//기능테스트 조건문</span>\n        target.attachEvent(<span class=\"hljs-string\">&#x27;onclick&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>{\n            alert(<span class=\"hljs-string\">&#x27;pure&#x27;</span>);\n        });\n    }\n \n    <span class=\"hljs-comment\">// jQuery를 사용했을 때</span>\n    $(<span class=\"hljs-string\">&#x27;#jquery&#x27;</span>).on(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>{<span class=\"hljs-comment\">//on API</span>\n        alert(<span class=\"hljs-string\">&#x27;jQuery&#x27;</span>);\n    })\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<ul>\n<li>\n<p>on API</p>\n<ul>\n<li>.on( events [, selector ] [, data ], handler(eventObject) )</li>\n<li>event : 등록하고자 하는 이벤트 타입을 지정한다. (예: &quot;click&quot;)</li>\n<li>selector : 이벤트가 설치된 엘리먼트의 하위 엘리먼트를 이벤트 대상으로 필터링함</li>\n<li>data : 이벤트가 실행될 때 핸들러로 전달될 데이터를 설정함</li>\n<li>handler : 이벤트 핸들러 함수</li>\n</ul>\n</li>\n<li>\n<p>on API- 필터링</p>\n</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>HTML<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>CSS<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>JavaScript<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;http://code.jquery.com/jquery-latest.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">                                         <span class=\"hljs-comment\">//selector </span>\n    $(<span class=\"hljs-string\">&#x27;ul&#x27;</span>).on(<span class=\"hljs-string\">&#x27;click&#x27;</span>,<span class=\"hljs-string\">&#x27;a, li&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>{ <span class=\"hljs-comment\">//ul태그 하위의 a태그와 li태그가 선택되었을 때로 필터링</span>\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.tagName); <span class=\"hljs-comment\">//a와 li중 클릭된 태그 출력</span>\n    })\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<pre><code>+ late binding\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;//code.jquery.com/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    $(<span class=\"hljs-string\">&#x27;body&#x27;</span>).on(<span class=\"hljs-string\">&#x27;click&#x27;</span>,<span class=\"hljs-string\">&#x27;a, li&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.tagName);\n    })\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>HTML<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>CSS<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>JavaScript<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</code></pre>\n<ul>\n<li>\n<p><code>$('ul').on('click','a, li', function(event)</code>과 같이 존재하지 않는 태그에 대해서는 이벤트를 달 수 없으나 $('body').on('click','a, li', function(event)라고 하면 존재하지 않는 태그에 대해서도 이벤트를 달 수 있다.</p>\n<ul>\n<li>다중 바인딩\n<ul>\n<li>하나의 엘리먼트에 여러개의 이벤트 타입을 동시에 등록 가능</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre class=\"hljs\"><code>$(<span class=\"hljs-string\">&#x27;#target&#x27;</span>).on(<span class=\"hljs-string\">&#x27;focus blur&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)</span>{ <span class=\"hljs-comment\">//focus와 blur과 같이 같은 이벤트에 동일한 이벤트 설치</span>\n    $(<span class=\"hljs-string\">&#x27;#status&#x27;</span>).html(e.type);\n})\n<span class=\"hljs-comment\">/*\nvar handler = function(e){\n   $(#status).html(e.type);\n}\n$(&#x27;#target&#x27;).on(&#x27;focus&#x27;, handler).on(&#x27;blur&#x27;,handler);\n로도 사용가능*/</span>\n</code></pre>\n<pre><code>+ 이벤트 제거\n</code></pre>\n<pre class=\"hljs\"><code>&lt;input type=<span class=\"hljs-string\">&quot;text&quot;</span> id=<span class=\"hljs-string\">&quot;target&quot;</span>&gt;&lt;/textarea&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;remove&quot;</span>  <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;remove&quot;</span> /&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;status&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;//code.jquery.com/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">var</span> handler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)</span>{\n    $(<span class=\"hljs-string\">&#x27;#status&#x27;</span>).text(e.type+<span class=\"hljs-built_in\">Math</span>.random());\n  };\n  $(<span class=\"hljs-string\">&#x27;#target&#x27;</span>).on(<span class=\"hljs-string\">&#x27;focus blur&#x27;</span>, handler)\n  $(<span class=\"hljs-string\">&#x27;#remove&#x27;</span>).on(<span class=\"hljs-string\">&#x27;click&#x27;</span> , <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)</span>{\n    $(<span class=\"hljs-string\">&#x27;#target&#x27;</span>).off(<span class=\"hljs-string\">&#x27;focus blur&#x27;</span>, handler); <span class=\"hljs-comment\">//몇개의 이벤트가 등록되어있던 한 방에 정리</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">32</span>);\n  })\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<h2>네트워크 통신 <a id=\"N9\"></a></h2>\n<ul>\n<li>자바 스크립트를 이용해서 내부적으로 통신을 할 수 있는 방법</li>\n</ul>\n<h3>1. Ajax(Asynchronous JavaScript and XML)</h3>\n<ul>\n<li>비동기적 자바스크립트와 XML</li>\n<li>자바 스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 주고받는 방식</li>\n<li>사용하는 API: XMLHttpRequest</li>\n</ul>\n<pre class=\"hljs\"><code>&lt;p&gt;time : <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;time&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>&lt;/p&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;execute&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;execute&quot;</span> /&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;input&#x27;</span>).addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>{\n    <span class=\"hljs-keyword\">var</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();\n    xhr.open(<span class=\"hljs-string\">&#x27;GET&#x27;</span>, <span class=\"hljs-string\">&#x27;./time.php&#x27;</span>); <span class=\"hljs-comment\">//get방식으로 time.php와 통신하겠다</span>\n    xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ <span class=\"hljs-comment\">//통신하며 상태가 변할 때마다 onreadystatechange호출</span>\n        <span class=\"hljs-keyword\">if</span>(xhr.readyState === <span class=\"hljs-number\">4</span> &amp;&amp; xhr.status === <span class=\"hljs-number\">200</span>){ <span class=\"hljs-comment\">//통신이 완료했고 성공했을 경우</span>\n            <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#time&#x27;</span>).innerHTML = xhr.responseText; <span class=\"hljs-comment\">//서버에서 받아온 값을 넣어주겠다.</span>\n        }\n    }\n    xhr.send(); <span class=\"hljs-comment\">//send가 호출될 때 xhr.open(&#x27;GET&#x27;, &#x27;./time.php&#x27;);로 통신을 시작</span>\n}); \n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span> \n</code></pre>\n<ul>\n<li>post방식</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>time : <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;time&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;timezone&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;Asia/Seoul&quot;</span>&gt;</span>asia/seoul<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;America/New_York&quot;</span>&gt;</span>America/New_York<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;format&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;Y-m-d H:i:s&quot;</span>&gt;</span>Y-m-d H:i:s<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;Y-m-d&quot;</span>&gt;</span>Y-m-d<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;execute&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;execute&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;input&#x27;</span>).addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>{\n    <span class=\"hljs-keyword\">var</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();\n    xhr.open(<span class=\"hljs-string\">&#x27;POST&#x27;</span>, <span class=\"hljs-string\">&#x27;./time2.php&#x27;</span>);\n    xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#time&#x27;</span>).innerHTML = xhr.responseText;\n    }\n    xhr.setRequestHeader(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;application/x-www-form-urlencoded&quot;</span>);\n    <span class=\"hljs-keyword\">var</span> data = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n    data += <span class=\"hljs-string\">&#x27;timezone=&#x27;</span>+<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;timezone&#x27;</span>).value;\n    data += <span class=\"hljs-string\">&#x27;&amp;format=&#x27;</span>+<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;format&#x27;</span>).value;\n    xhr.send(data); \n});\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span> \n</code></pre>\n<pre><code>+ timezone=Asia/Seoul&amp;format=Y=m-d\n+ 값과 값 구분 &amp;\n+ 값의 이름과 값의 내용 =\n</code></pre>\n<h3>2. JSON(JavaScript Object Notation)</h3>\n<ul>\n<li>자바 스크립트에서 객체를 만들 때 사용하는 표현식\n<ul>\n<li><code>var person = {&quot;height&quot;:174, &quot;job&quot;:&quot;programmer&quot;}</code> - 객체</li>\n<li><code>var member = [&quot;height&quot;, &quot;job&quot;,&quot;programmer&quot;]</code> - 배열</li>\n<li>배열이나 객체 상태 그대로 보낼 수 있는 방식이 없다</li>\n<li>이러한 불편을 해소하기 위해 만든 규칙 json</li>\n<li>줄바꿈시 \\처리</li>\n</ul>\n</li>\n<li>API\n<ul>\n<li>JSON.parse(): 인자로 전달된 문사열을 자바스크립트의 데이터로 변환한다.</li>\n</ul>\n</li>\n</ul>\n<pre class=\"hljs\"><code>&gt; var info = '{\\\n   &quot;font_face&quot; : &quot;iconsolata&quot;,\\\n   &quot;font_size&quot;: 30,\\\n   &quot;ignored_packages&quot;:\\\n   [\\\n   ],\\\n   &quot;line_numbers&quot;: false\\\n}'\n\n&gt; info\n&quot;{ &quot;font_face&quot; : &quot;iconsolata&quot;, &quot;font_size&quot;: 30, &quot;ignored_packages&quot;: [  ], &quot;line_numbers&quot;: false}&quot;\n\n&gt; var infoobj = JSON.parse(info);\n{font_face: &quot;iconsolata&quot;, font_size: 30, ignored_packages: Array(0), line_numbers: false}\n</code></pre>\n<pre><code>+ JSON.stringify(): 인자로 전달된 자바스크립트의 데이터를 문자열로 변환한다.\n</code></pre>\n<h3>3. JSON 포맷을 이용한 Ajax 통신</h3>\n<pre class=\"hljs\"><code>&lt;?php\n$timezones = [&quot;Asia/Seoul&quot;, &quot;America/New_York&quot;];\nheader('Content-Type: application/json');\necho json_encode($timezones);//php데이터를 json 형식으로 전환\n?&gt; //결과: [&quot;Asia\\/Seoul&quot;,&quot;America\\/New_York&quot;]\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;timezones&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;execute&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;execute&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;input&#x27;</span>).addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>)</span>{\n<span class=\"hljs-keyword\">var</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();\nxhr.open(<span class=\"hljs-string\">&#x27;GET&#x27;</span>, <span class=\"hljs-string\">&#x27;./time2.php&#x27;</span>);\nxhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n<span class=\"hljs-keyword\">if</span>(xhr.readyState === <span class=\"hljs-number\">4</span> &amp;&amp; xhr.status === <span class=\"hljs-number\">200</span>){\n<span class=\"hljs-keyword\">var</span> _tzs = xhr.responseText;\n<span class=\"hljs-keyword\">var</span> tzs = <span class=\"hljs-built_in\">JSON</span>.parse(_tzs); <span class=\"hljs-comment\">// 서버에서 전송한 json 데이터를 자바스크립트 배열로 전환</span>\n<span class=\"hljs-keyword\">var</span> _str = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i&lt; tzs.length; i++){\n_str += <span class=\"hljs-string\">&#x27;&lt;li&gt;&#x27;</span>+tzs[i]+<span class=\"hljs-string\">&#x27;&lt;/li&gt;&#x27;</span>;\n}\n_str = <span class=\"hljs-string\">&#x27;&lt;ul&gt;&#x27;</span>+_str+<span class=\"hljs-string\">&#x27;&lt;/ul&gt;&#x27;</span>;\n \n  <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#timezones&#x27;</span>).innerHTML = _str;\n      }\n   }\nxhr.send(); \n}); \n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span> \n</code></pre>\n<h3>4. jQuery Ajax 통신</h3>\n<ul>\n<li>jOuery를 이용하여 Ajax를 사용하게 되면 크로스 브라우징 이슈가 제이쿼리에 의해 해결된다</li>\n<li>여러가지 편리한 가능 제공</li>\n<li><a href=\"https://api.jquery.com/category/ajax/\">jQuery Ajax API</a></li>\n<li>jQuery.ajax( url [, settings ] )\n<ul>\n<li>$.ajax(url, settings)</li>\n<li>data: 서버로 데이터를 전송할 때 이 옵션을 사용한다.</li>\n<li>dataType: 서버측에서 전송한 데이터를 어떤 형식의 데이터로 해석할 것인가를 지정한다. 값으로 올 수 있는 것은 xml, json, script, html이다. 형식을 지정하지 않으면 jQuery가 알아서 판단한다.</li>\n<li>success: 성공했을 때 호출할 콜백을 지정한다. Function( PlainObject data, String textStatus, jqXHR jqXHR )</li>\n<li>type: 데이터를 전송하는 방법을 지정한다. get, post를 사용할 수 있다.</li>\n</ul>\n</li>\n</ul>\n",
  "__v": 0
},{
  "_id": {
    "$oid": "5f3114efa6248f091489e7c8"
  },
  "createdAt": {
    "$date": "2020-08-10T09:44:15.896Z"
  },
  "title": "유저별 테스트",
  "user": "wodyd318@naver.com",
  "markdown": "# 삭제 테스트 성공\r\n\r\n# 편집 테스트 성공",
  "makrdownHtml": "<h1 id=\"삭제-테스트-성공\">삭제 테스트 성공</h1>\n<h1 id=\"편집-테스트-성공\">편집 테스트 성공</h1>\n",
  "__v": 0
},{
  "_id": {
    "$oid": "5f311539a6248f091489e7ca"
  },
  "createdAt": {
    "$date": "2020-08-10T09:44:24.311Z"
  },
  "title": "동영상 mp4 테스트",
  "user": "wodyd318@naver.com",
  "markdown": "<video id=\"myVideo\" controls autoplay loop preload>\r\n<source src=\"http://techslides.com/demos/sample-videos/small.mp4\"></source>\r\n</video>\r\n\r\n\r\n코드\r\n\r\nvideo id=\"myVideo\" controls autoplay loop preload\r\n\r\nsource src=\"http://techslides.com/demos/sample-videos/small.mp4\"\r\n\r\n/source\r\n\r\n/video\r\n\r\n",
  "makrdownHtml": "<video preload=\"\" loop=\"\" autoplay=\"\" controls=\"\" id=\"myVideo\">\n<source src=\"http://techslides.com/demos/sample-videos/small.mp4\">\n</video>\n\n\n<p>코드</p>\n<p>video id=\"myVideo\" controls autoplay loop preload</p>\n<p>source src=\"<a href=\"http://techslides.com/demos/sample-videos/small.mp4&quot;\">http://techslides.com/demos/sample-videos/small.mp4\"</a></p>\n<p>/source</p>\n<p>/video</p>\n",
  "__v": 0
},{
  "_id": {
    "$oid": "5f324d52e3ea5b2a9083f4c1"
  },
  "createdAt": {
    "$date": "2020-08-18T02:36:40.315Z"
  },
  "title": "YouTube 동영상 테스트",
  "user": "agratos318@naver.com",
  "markdown": "# YouTube\r\n\r\n@[YouTube](https://youtu.be/ykaewXfsrLg)\r\n\r\n## 저장 방법페이지를 편집중\r\n\r\n@ 사용후 ( YouTube URL ) 삽입",
  "makrdownHtml": "<h1>YouTube</h1>\n<p><div class=\"embed-responsive embed-responsive-16by9\"><iframe class=\"embed-responsive-item youtube-player\" type=\"text/html\" width=\"640\" height=\"390\" src=\"https://www.youtube.com/embed/ykaewXfsrLg\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div></p>\n<h2>저장 방법페이지를 편집중</h2>\n<p>@ 사용후 ( YouTube URL ) 삽입</p>\n",
  "__v": 0
},{
  "_id": {
    "$oid": "5f62f91d83ccd13290f474bb"
  },
  "createdAt": {
    "$date": "2020-09-17T05:51:40.699Z"
  },
  "title": "프론트엔드 추천 자료 모음",
  "user": "tamd5971@naver.com",
  "markdown": "[원글](https://velog.io/@ansrjsdn/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B6%94%EC%B2%9C-%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C)\r\n\r\n![velog](https://media.vlpt.us/images/ansrjsdn/post/eaa4af70-f583-47ea-98cd-e4eb7e20fc63/image.png)\r\n# 사이트\r\n[MDN](https://developer.mozilla.org/ko/) - 가장 유명한 MDN\r\n\r\n모던 javascript 튜토리얼 - JS 튜토리얼로 정말 좋음.\r\n\r\n타입스크립트 핸드북 - TS 공식문서 번역본\r\n\r\n웹팩 핸드북 - 캡틴판교님의 웹팩 핸드북\r\n\r\nfontawesome - 다양한 ICON을 가져올 수 있는 사이트\r\n\r\nflatuicolors - 다양한 색들을 가져오기 편한 사이트\r\n\r\nCSS Dinner - 다양한 css 선택자들을 게임을 통해 배울 수 있는 사이트\r\n\r\nFLEXBOX FROGGY - css의 FLEXBOX를 게임을 통해 배울 수 있는 사이트\r\n\r\nGRID GARDEN CSS의 grid를 게임을 통해 배울 수 있는 사이트\r\n\r\n\r\n# 블로그\r\nVelopert velog - velog를 만든 velopert님의 velog로 정말 좋은 글들이 많음.\r\n\r\n제로초 블로그 - 다양한 JS 관련 지식들이 있음.\r\n\r\nJbee 블로그 - 다양한 프론트엔드 관련 지식들\r\n\r\nTOAST UI - FE 관련 지식들과 여러 글들\r\n\r\n캡틴판교 블로그 - JS 및 VUE 관련 글들이 많음.\r\n\r\nEvan moon 블로그 - 다양한 프론트엔드 관련 글들\r\n\r\nNAVER D2\r\n우아한형제들 기술 블로그\r\n라인 기술 블로그 - 프론트\r\n\r\n# 깃허브\r\n\r\n주니어 개발자 채용 정보 - 주니어 개발자들이 지원 할만한 다양한 채용 정보 모음.\r\n\r\n고퀄리티 개발 모음 - 다양한 개발에 대한 지식들을 모아 둔 곳.\r\n\r\nTechnical Interview Guidelines for Beginners - 다양한 면접 관련 질문들을 모아둔 곳.\r\n\r\n취준생이 반드시 알아야 할 프론트엔드 지식들 - 프론트엔드 개발자들을 위한 지식들. 면접에 많이 나옴\r\n\r\n유튜브\r\n노마드 코더 Nomad Coders - 우리의 니꼴라스 선생님. React를 배울 수 있고 프로그래밍의 전반적인 내용들을 배울 수 있음.\r\n\r\n드림코딩 by 엘리 - 기초부터 자세하게 배울 수 있음. 일주일에 1강 정도 꾸준히 올라옴. 애청자입니다 ㅎㅎ\r\n\r\nZeroCho TV - 기초부터 React, ts까지 배울 수 있음. 무료 강좌들은 유튜브에 있고 유료 강좌들은 인프런에 있음. 유료 강좌는 유튜브에서 찍고 있을 때 들으면 무료입니다.\r\n\r\n코드 스피츠 - js의 깊은 부분까지 가르쳐 주는 곳인거 같습니다. 아직 들어보진 않았음. 좋아 보여서 들을 예정.\r\n\r\n김버그 Kimbug - 프론트엔드 개발자 일상이라던지, 공부 추천 같은 영상들 올라옴. 요즘은 프린이들 코드 리뷰 영상 올라와서 매우 공감 됨.\r\n\r\nDarkCode - 외국 유튜버인데 html, css만 가지고 많은 화면들을 만듦. 따라 치면서 html, css 공부하기 좋음.\r\n\r\nMinjun Kim - velopert님 유튜브. 요즘은 방송 안 하시지만 velog 만들 때의 영상을 볼 수 있음.\r\n\r\n프론트엔드 개발 환경의 이해 - 김정환\r\nVue.js 개발 입문 - 캡틴판교\r\njavascript로 함수형 프로그래밍 배우기\r\n함수형 프로그래밍과 ES6+ - 유인동\r\nNAVER TECH CONCERT 2019 - FRONT END\r\n\r\n기타\r\n벨로퍼트와 함께 하는 모던 자바스크립트\r\n벨로퍼트와 함께 하는 모던 리액트\r\n리액트를 다루는 기술(개정판)\r\n실용주의 프런트엔드 개발\r\nTypeScript Cookbook\r\nDevFest WebTech CodeLab 2019\r\n\r\n제가 좋아하거나 봤던 것이나 볼 것이거나... 그런 자료들 모음입니다. 참고 하실분 참고하세요~ 다른 좋은 사이트 있으면 추천해주시면 감사하겠습니당.\r\n\r\n",
  "makrdownHtml": "<p><a href=\"https://velog.io/@ansrjsdn/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B6%94%EC%B2%9C-%EC%9E%90%EB%A3%8C-%EB%AA%A8%EC%9D%8C\">원글</a></p>\n<p><img src=\"https://media.vlpt.us/images/ansrjsdn/post/eaa4af70-f583-47ea-98cd-e4eb7e20fc63/image.png\" alt=\"velog\"></p>\n<h1>사이트</h1>\n<p><a href=\"https://developer.mozilla.org/ko/\">MDN</a> - 가장 유명한 MDN</p>\n<p>모던 javascript 튜토리얼 - JS 튜토리얼로 정말 좋음.</p>\n<p>타입스크립트 핸드북 - TS 공식문서 번역본</p>\n<p>웹팩 핸드북 - 캡틴판교님의 웹팩 핸드북</p>\n<p>fontawesome - 다양한 ICON을 가져올 수 있는 사이트</p>\n<p>flatuicolors - 다양한 색들을 가져오기 편한 사이트</p>\n<p>CSS Dinner - 다양한 css 선택자들을 게임을 통해 배울 수 있는 사이트</p>\n<p>FLEXBOX FROGGY - css의 FLEXBOX를 게임을 통해 배울 수 있는 사이트</p>\n<p>GRID GARDEN CSS의 grid를 게임을 통해 배울 수 있는 사이트</p>\n<h1>블로그</h1>\n<p>Velopert velog - velog를 만든 velopert님의 velog로 정말 좋은 글들이 많음.</p>\n<p>제로초 블로그 - 다양한 JS 관련 지식들이 있음.</p>\n<p>Jbee 블로그 - 다양한 프론트엔드 관련 지식들</p>\n<p>TOAST UI - FE 관련 지식들과 여러 글들</p>\n<p>캡틴판교 블로그 - JS 및 VUE 관련 글들이 많음.</p>\n<p>Evan moon 블로그 - 다양한 프론트엔드 관련 글들</p>\n<p>NAVER D2\n우아한형제들 기술 블로그\n라인 기술 블로그 - 프론트</p>\n<h1>깃허브</h1>\n<p>주니어 개발자 채용 정보 - 주니어 개발자들이 지원 할만한 다양한 채용 정보 모음.</p>\n<p>고퀄리티 개발 모음 - 다양한 개발에 대한 지식들을 모아 둔 곳.</p>\n<p>Technical Interview Guidelines for Beginners - 다양한 면접 관련 질문들을 모아둔 곳.</p>\n<p>취준생이 반드시 알아야 할 프론트엔드 지식들 - 프론트엔드 개발자들을 위한 지식들. 면접에 많이 나옴</p>\n<p>유튜브\n노마드 코더 Nomad Coders - 우리의 니꼴라스 선생님. React를 배울 수 있고 프로그래밍의 전반적인 내용들을 배울 수 있음.</p>\n<p>드림코딩 by 엘리 - 기초부터 자세하게 배울 수 있음. 일주일에 1강 정도 꾸준히 올라옴. 애청자입니다 ㅎㅎ</p>\n<p>ZeroCho TV - 기초부터 React, ts까지 배울 수 있음. 무료 강좌들은 유튜브에 있고 유료 강좌들은 인프런에 있음. 유료 강좌는 유튜브에서 찍고 있을 때 들으면 무료입니다.</p>\n<p>코드 스피츠 - js의 깊은 부분까지 가르쳐 주는 곳인거 같습니다. 아직 들어보진 않았음. 좋아 보여서 들을 예정.</p>\n<p>김버그 Kimbug - 프론트엔드 개발자 일상이라던지, 공부 추천 같은 영상들 올라옴. 요즘은 프린이들 코드 리뷰 영상 올라와서 매우 공감 됨.</p>\n<p>DarkCode - 외국 유튜버인데 html, css만 가지고 많은 화면들을 만듦. 따라 치면서 html, css 공부하기 좋음.</p>\n<p>Minjun Kim - velopert님 유튜브. 요즘은 방송 안 하시지만 velog 만들 때의 영상을 볼 수 있음.</p>\n<p>프론트엔드 개발 환경의 이해 - 김정환\nVue.js 개발 입문 - 캡틴판교\njavascript로 함수형 프로그래밍 배우기\n함수형 프로그래밍과 ES6+ - 유인동\nNAVER TECH CONCERT 2019 - FRONT END</p>\n<p>기타\n벨로퍼트와 함께 하는 모던 자바스크립트\n벨로퍼트와 함께 하는 모던 리액트\n리액트를 다루는 기술(개정판)\n실용주의 프런트엔드 개발\nTypeScript Cookbook\nDevFest WebTech CodeLab 2019</p>\n<p>제가 좋아하거나 봤던 것이나 볼 것이거나... 그런 자료들 모음입니다. 참고 하실분 참고하세요~ 다른 좋은 사이트 있으면 추천해주시면 감사하겠습니당.</p>\n",
  "__v": 0
},{
  "_id": {
    "$oid": "5f62fae383ccd13290f474bd"
  },
  "createdAt": {
    "$date": "2020-09-17T06:17:52.562Z"
  },
  "title": "웹 프론트 속도 개선을 위한 필수도구 소개",
  "user": "tamd5971@naver.com",
  "markdown": "[원글 링크](https://velog.io/@dochis/%EC%9B%B9-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%95%84%EC%88%98%EB%8F%84%EA%B5%AC-%EC%86%8C%EA%B0%9C)\r\n\r\n![마지 심슨](https://media.vlpt.us/images/dochis/post/16986537-cf95-48c6-ada7-3f8857f97c45/GregariousGenuineKoalabear-size_restricted.gif)\r\n\r\n\r\n# 😒 왜 우리 사이트는 느린가\r\n사이트가 느려지는 원인은 다음과 같이 매우 다양합니다.\r\n(참고로 필자는 back-end개발자입니다, 분란의 오해 없으시길 바랍니다.)\r\n\r\n## Case.1 \"일단 프론트는 나가있어\" 유형\r\n> 일단 프론트 영역은 아니라고 생각되는 유형\r\n> + 서버 / back-end / Middleware가 잘못했네.!\r\n> + 서버회사 인터넷 회선이 느리네!\r\n\r\n## Case.2 \"궁예 : 누구인가??...\" 유형\r\n> 궁예 : 누구인가? 누가 속도 이슈를 내었서?...\r\n> + 정적콘텐츠(이미지/js/css 등)의 전송속도\r\n> + 너무 무거운 스크립트\r\n> + 너무 무거운 이미지\r\n> + 뜻하지 않은 버그로 인한 무한루프\r\n> + 등등 ~~2,147,483,644가지 경우~~\r\n\r\n---\r\n> Tip. 느림의 기준?\r\n> 필자의 경우 2.7초를 초과 할 경우 느리다고 생각하고 있습니다.\r\n> 많은 보고서에서 로딩이 3초를 초과할 경우\r\n> 50% 정도의 사용자는 사이트를 이탈한다고 말합니다.!\r\n>\r\n> [그 보고서 자세히 보고싶어요! (akamai 보고서)](https://www.akamai.com/kr/ko/multimedia/documents/report/akamai-state-of-online-retail-performance-spring-2017.pdf)\r\n\r\n# 😶 오늘 사용할 도구\r\n오늘 소개할 도구는 JENNIFERSOFT사의 JENNIFER Front입니다.\r\n현재 구글 계정만 있다면 **무료**로 사용하실 수 있습니다.\r\n\r\n[JENNIFER Front 바로가기](http://asq.kr/zso40e7v2kYo)\r\n\r\n> JENNIFERSOFT사 소속의 Irene님께서\r\n> '유료 계획은 현재까지는 없습니다~' 라고 답변해주셨습니다.\r\n\r\n\r\n![그래프](https://media.vlpt.us/images/dochis/post/4e1bba42-3e74-48b0-b058-0f0e6af08869/dashboard.gif)\r\n# 😏 와 저 오른쪽 그래프 이쁘다\r\n![그래프2](https://media.vlpt.us/images/dochis/post/405c6a0b-314f-4e8c-b093-6b504a7e5fcb/image.gif)\r\n\r\n~~손님! 안목이 있으시군요!.~~ JENNIFER의 핵심인 x-view 화면입니다.\r\n그런데 세로축이 페이지 로딩에 소요된 시간입니다.\r\n위쪽을 보시면 5초 이상의 노란색~빨간색 표시가 보이시죠??\r\n\r\n그 의미는 사이트가 아주!! 느린다는 겁니다\r\n다시 그래프를 보시면, 이쁘시지마는 않을 거예요.\r\n\r\nJENNIFER에서는 5초 미만의 페이지의 경우 초록색, 5초~10초 구간은 노란색, 10초 이상은 빨간색으로 표시하고 있습니다.\r\n\r\n# 🙄 왜 느릴까?\r\nx-view 화면에서 원하시는 영역을 드래그 하시면 페이지가 느린지 알 수 있습니다.\r\n\r\n저는 빨간색 영역을 드래그 해보겠습니다.\r\n\r\n![드래그](https://media.vlpt.us/images/dochis/post/b000862c-556c-4648-a8b5-53cc3d7396b3/x-view.gif)\r\n![드래그2](https://media.vlpt.us/images/dochis/post/749e3e43-c357-4ca9-9d6f-f5a26cafdff3/image.png)\r\n\r\nJENNIFER Front에서 사용하는 추적옵션은 다음과 같은 6종류입니다.\r\n\r\n+ 대기\r\n> http request 시작 후 Server에서 데이터를 보내기까지 대기시간\r\n+ Server\r\n> Server에서 데이터를 보내는 시간\r\n+ Network\r\n> http request 시작 후 response를 받는 시점까지\r\n+ Dom\r\n> response에서 Dom을 로드 하는 시간\r\n+ Render\r\n> Dom을 로드하고 css/js 등을 통해 페이지를 렌더링하는 시간\r\n+ 로드\r\n> 렌더링 이후 로드에 소요된 시간\r\n\r\n# 😣 아.. 뭐야! 둘 다 잘못했네!\r\n맞습니다.! 위 화면에서 Network 구간에서 2.3초나 소요되었고 Dom을 로드하고 Render 하는 구간에서 3.7초나 소요되었습니다. 나머지 서버 로딩 지연 등을 포함해 사용자는 웹 페이지를 로딩하는데 9.3초를 소비하게 되었죠 (😱끔찍하네요)\r\n\r\n🤵대표님 : 개발팀 집합....\r\n\r\n# 🤩 어떻게 분석하나요?\r\n가장 많이 발생되는 지연구간별 원인은 다음과 같습니다.\r\n\r\n1. Server/Network 구간\r\n+ 이 두 구간은 브라우저가 html을 받기까지의 구간입니다. Network 시간\r\n+ Server 시간을 한다면 순수 전송에 소요된 시간을 알 수 있습니다. 순수 전송에 소요 된 시간이 적다면 Server의 문제로 보입니다. html를 반환하는 과정에서 오래 소요되는 구간을 찾을 필요가 있습니다.\r\n+ 순수 전송 소요시간이 길다면, Network 구성에 문제가 있을 수 있습니다. CDN 서비스를 사용하거나 캐싱 처리해 최적화 할 필요가 있습니다.\r\n\r\n2. Dom/Render 구간\r\n+ 이 두 구간은 브라우저가 html을 받고 Dom을 처리하거나 Rendering 하는 과정의 이슈 구간입니다.\r\n+ Dom 구간이 느리다면 Dom이 너무 중첩되거나 무겁지 않은지 확인이 필요합니다.\r\n+ Render 구간이 느리다면 Font/Javasciprt/Css등 Rendering 지연 파일들의 Network 전송 이슈는 없었는지 확인합니다. 있었다면 Network 구간의 정비가 필요합니다. 없었다면 원인이 Javasciprt로 인한 것인지 다른 기타요인으로 인한 것인지 확인이 필요합니다.\r\n+ 타임라인을 내려보면, 파일별로 Rendering을 볼 수 있어, 개별적으로 확인 후 분석이 필요합니다.\r\n\r\n# 😓 어렵죠..? 예시로 설명함돠!\r\n## 🙋‍ CDN을 쓰는데 Network 구간이 느려요\r\n정적콘텐츠(Javascript/이미지/CSS/Font 등)의 전송을 빠르게 하고자 CDN(Contents Delivery Network)를 많이 활용하실 텐데요, CDN을 너무 맹신하시면 안 됩니다\r\n\r\n우리는 CDN을 쓰니까 모든 지역에서 빠르겠지?! 는 오해일 수 있습니다.\r\n지역에 따라 전송이 느린 서비스가 종종 있기 때문이죠!\r\n\r\nJENNIFER Front의 Resource 분석에서는, 각 정적콘텐츠가 지역별로 로딩에 어느 정도 소요되었는지 볼 수 있습니다.\r\n\r\n![지역별로딩](https://media.vlpt.us/images/dochis/post/b40ae23e-8f2a-4e7d-9cb5-6dd391c2b830/image.gif)\r\n\r\n위처럼 CDN을 사용하더라도 일부 구간에서 로딩이 느릴 수 있습니다.\r\n🏃‍♀️앗! 팀장님~~!! 우리 CDN 서비스 바꿔요!!!\r\n\r\n## 🙋‍♂️ SPA 서비스에서 Ajax로 통신을 하고 있어요\r\nSPA(Single Page Application)를 사용하는 경우, html과 Javascript를 먼저 반환하고 데이터는 Ajax를 통해 불러오는 경우가 많은데요!\r\n\r\nAjax에서 데이터 받는 시간이 길어져 사용자의 입장에서 렌더링이 느리게 느껴질 수 있답니다.!\r\n\r\n아래와 같이 Ajax 통신만 담당하는 담당 일찐 페이지가 따로 있어요!\r\n시간에 따른 호출수/지연시간/Error 발생 비율 등을 볼 수 있습니다.\r\n\r\n![ajax담당](https://media.vlpt.us/images/dochis/post/82bef7dc-a02e-43d2-a855-68769447f1a4/image.png)\r\n\r\n## 🙋‍ JS 라이브러리는 외부에서 당겨쓰니까 빠르겠죠?\r\n안일한 생각은 NO !\r\n아래 사진은 '다음' CDN에서 배포하는 이미지 파일에 대한 로그입니다.\r\n\r\n서울특별시에서 평균 4.9초의 응답속도를 보이는 것으로 확인되는데요,\r\n이런 듯 공신력 있는 CDN 서비스에서 배포하는 파일이라도 방심은 할 수 없습니다!\r\n\r\n서비스 로딩에 지연을 주는 중요한 파일이라면 꼭! 안정적인 CDN서비스를 통해 배포해야 합니다!\r\n\r\n![이미지용 서버](https://media.vlpt.us/images/dochis/post/16408823-f9b9-4438-93c0-6648739a90f5/image.png)\r\n\r\n## 🙋‍♂️ 우리는 이미지용 서버를 따로 쓰고 있어요!\r\n혹시 해당 서버에서 배포하는 정적 파일들은 안전하게 호스팅 되고 있을까요?!\r\n\r\nJENNIFER Front에서는 아래 사진과 같이 정적 컨텐츠들을 url 규칙에 맞게 자동으로 그룹화하여 url 그룹 별 통계를 제공합니다.\r\n\r\n아래 사진을 보면, 호출이 몰리는 일부 구간에서 다운로드 시간이 평균 0.27초에서 0.54초 속도가 튀는게 보이시죠?!\r\n\r\n0.54초가 짧게 보일 수 있지만, 게시물을 예로 들면 한 게시물 내에 수십개의 이미지가 첨부될 수 있기 때문에 짧지만은 않은 지연시간입니다.!\r\n\r\n> 😱 이미지 서버뿐 아니에요!\r\n> 우리가 자주 사용하는 파일용서버/스트리밍용 서버 등에서도\r\n> 비슷한 경우가 자주 발생한답니다!\r\n> 각 url 그룹별로 지연원인은 없는지 자주 분석하는게 좋아요!\r\n\r\n![웹폰트](https://media.vlpt.us/images/dochis/post/3c9236c0-052d-41b3-a784-9ddd917b885c/image.png)\r\n\r\n## 🙋‍ 당신의 웹 폰트는 안녕하신가요?\r\n여러분들께서 사용하시는 웹 폰트는 안녕하신가요?\r\n국내에서 많이 사용하는 NotoSansKR, 나눔고딕 등의 폰트는 사실 매우 무겁습니다.\r\n\r\n로딩하고 랜더링하는데에 2초 가량이 소요되죠!\r\n\r\n때문에 웹 폰트를 항상 경량화 하고 랜더링을 비동기로 처리하는 것이 중요합니다.!\r\n\r\n![경량화](https://media.vlpt.us/images/dochis/post/02bd846e-1413-48cf-a62d-325b0f6b2381/image.png)\r\n\r\n웹폰트 최적화와 경량화에 대해 자세히 소개한 게시물을 알려드릴게요!\r\n\r\n+ [웹 폰트 사용과 최적화의 최근 동향 (Naver D2)](https://d2.naver.com/helloworld/4969726)\r\n+ [웹 폰트 경량화 (INDIV.BLOG)](http://indivdot.github.io/%EC%9B%B9/2016/04/02/webfont.html)\r\n+ [웹폰트 올바른 방법으로 로딩하자 (웹아틀리에)](https://web-atelier.tistory.com/43)\r\n\r\n# 😳 뜻밖의 꿀팁!\r\nJavascript Error 분석기능도 있습니다.!\r\nJavascript Error가 발생할 경우 수집하여 브라우저 정보 등과 함께 제공합니다.!\r\n\r\n> 😥 왜, 한번씩 그런경우 있잖아요!\r\n> 특정 사용자한테만 나타나는 스크립트 에러말이에요!\r\n> 이러한 경우에도 console 상에 에러가 발생되면 자동으로 수집된답니다.!\r\n\r\n![통계](https://media.vlpt.us/images/dochis/post/054b17b5-9d7e-43eb-9949-02d3675633d3/image.png)\r\n\r\n그 이외에도 브라우저 통계, 사용자별 통계, 리소스 그룹별 통계 등 다양한 기능이 있습니다.\r\n\r\n> 사용자별 통계 기능은 해당 사용자가 방문했었던 모든 페이지를 시간순으로 볼 수\r\n> 있어요! 디버깅에 활용 할 수 있는 뜻밖의 꿀기능이랍니다.!\r\n\r\n# 👍 속도개선방법 == 원인제거\r\n지금까지 웹 속도를 느리게 하는 다양한 원인을 분석하는 방법을 알아보았습니다.\r\n\r\n웹 서비스의 속도를 개선하는 방법은 이러한 속도를 느리게 하는 문제를 해결하는 데에 있습니다. 지금까지 소개한 내용을 요약해보도록 하겠습니다.\r\n\r\n### < 속도를 개선하는 방법 >\r\n\r\n+ 서버에서 브라우저의 Request에 더 빠른 반응을 하도록 하고 더 빠른 Response를 반환하도록 개선 (캐싱 등)\r\n+ 서버에서 반환하는 Response를 빠르게 브라우저에 전달할 수 있도록 Network 구간을 개선 (gzip 등)\r\n+ 웹 페이지의 랜더링을 지연시키는 요소를 제거 (Javascript 튜닝 등)\r\n+ 정적 콘텐츠들을 더 빠르고 안정적으로 호스팅할 수 있는 CDN 서비스 선택\r\n+ 정적 콘텐츠들을 브라우저 스토리지에 캐싱\r\n+ 정적 콘텐츠 요청시 HTTP/2, HTTP/3 등의 상위 프로토콜 사용추천\r\n\r\n으로 정리해볼 수 있을 것 같습니다.\r\n\r\n# 👋 마치며\r\n오늘은 APM(Application Performance Management)도구 중 front-end 개발자가 사용하면 좋을 도구에 대해 소개해보았습니다.\r\n\r\n**이 멋진 도구는 Javascript 몇 줄을 추가하는 것만으로 쉽게 사용하실 수 있습니다.!**\r\n\r\n이렇게 멋진 소프트웨어를 무료로 사용할 수 있다는 점이 정말 좋은 것 같습니다.\r\n\r\n> ps) 😎 이 게시물을 회사 대표님이 못 보게 하세요.!\r\n\r\n> 궁금하신 내용이나 프로그램 사용 중 막히는 부분이 있다면 언제든지 댓글로\r\n> 문의하여 주세요.! 댓글은 환영입니다.!\r\n\r\n도움을 주신 많은 분들께 감사드립니다.\r\n\r\n# 💪 함께 하면 좋을 링크\r\n[무료로 서비스를 모니터링하는 3가지 방법](https://blog.dochis.net/2020/09/06/Ways-to-Monitor-Service-for-Free.html?utm_source=velog&utm_medium=post&utm_campaign=399f85b4-8680-40c9-8c38-becfe3794eb2)\r\n\r\n[제니퍼 프론트 사이트](https://front.jennifersoft.com/about/ko/)\r\n\r\n[제니퍼소프트 사이트](https://jennifersoft.com/ko/)",
  "makrdownHtml": "<p><a href=\"https://velog.io/@dochis/%EC%9B%B9-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%95%84%EC%88%98%EB%8F%84%EA%B5%AC-%EC%86%8C%EA%B0%9C\">원글 링크</a></p>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/16986537-cf95-48c6-ada7-3f8857f97c45/GregariousGenuineKoalabear-size_restricted.gif\" alt=\"마지 심슨\"></p>\n<h1>😒 왜 우리 사이트는 느린가</h1>\n<p>사이트가 느려지는 원인은 다음과 같이 매우 다양합니다.\n(참고로 필자는 back-end개발자입니다, 분란의 오해 없으시길 바랍니다.)</p>\n<h2>Case.1 &quot;일단 프론트는 나가있어&quot; 유형</h2>\n<blockquote>\n<p>일단 프론트 영역은 아니라고 생각되는 유형</p>\n<ul>\n<li>서버 / back-end / Middleware가 잘못했네.!</li>\n<li>서버회사 인터넷 회선이 느리네!</li>\n</ul>\n</blockquote>\n<h2>Case.2 &quot;궁예 : 누구인가??...&quot; 유형</h2>\n<blockquote>\n<p>궁예 : 누구인가? 누가 속도 이슈를 내었서?...</p>\n<ul>\n<li>정적콘텐츠(이미지/js/css 등)의 전송속도</li>\n<li>너무 무거운 스크립트</li>\n<li>너무 무거운 이미지</li>\n<li>뜻하지 않은 버그로 인한 무한루프</li>\n<li>등등 <s>2,147,483,644가지 경우</s></li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p>Tip. 느림의 기준?\n필자의 경우 2.7초를 초과 할 경우 느리다고 생각하고 있습니다.\n많은 보고서에서 로딩이 3초를 초과할 경우\n50% 정도의 사용자는 사이트를 이탈한다고 말합니다.!</p>\n<p><a href=\"https://www.akamai.com/kr/ko/multimedia/documents/report/akamai-state-of-online-retail-performance-spring-2017.pdf\">그 보고서 자세히 보고싶어요! (akamai 보고서)</a></p>\n</blockquote>\n<h1>😶 오늘 사용할 도구</h1>\n<p>오늘 소개할 도구는 JENNIFERSOFT사의 JENNIFER Front입니다.\n현재 구글 계정만 있다면 <strong>무료</strong>로 사용하실 수 있습니다.</p>\n<p><a href=\"http://asq.kr/zso40e7v2kYo\">JENNIFER Front 바로가기</a></p>\n<blockquote>\n<p>JENNIFERSOFT사 소속의 Irene님께서\n'유료 계획은 현재까지는 없습니다~' 라고 답변해주셨습니다.</p>\n</blockquote>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/4e1bba42-3e74-48b0-b058-0f0e6af08869/dashboard.gif\" alt=\"그래프\"></p>\n<h1>😏 와 저 오른쪽 그래프 이쁘다</h1>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/405c6a0b-314f-4e8c-b093-6b504a7e5fcb/image.gif\" alt=\"그래프2\"></p>\n<p><s>손님! 안목이 있으시군요!.</s> JENNIFER의 핵심인 x-view 화면입니다.\n그런데 세로축이 페이지 로딩에 소요된 시간입니다.\n위쪽을 보시면 5초 이상의 노란색~빨간색 표시가 보이시죠??</p>\n<p>그 의미는 사이트가 아주!! 느린다는 겁니다\n다시 그래프를 보시면, 이쁘시지마는 않을 거예요.</p>\n<p>JENNIFER에서는 5초 미만의 페이지의 경우 초록색, 5초~10초 구간은 노란색, 10초 이상은 빨간색으로 표시하고 있습니다.</p>\n<h1>🙄 왜 느릴까?</h1>\n<p>x-view 화면에서 원하시는 영역을 드래그 하시면 페이지가 느린지 알 수 있습니다.</p>\n<p>저는 빨간색 영역을 드래그 해보겠습니다.</p>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/b000862c-556c-4648-a8b5-53cc3d7396b3/x-view.gif\" alt=\"드래그\">\n<img src=\"https://media.vlpt.us/images/dochis/post/749e3e43-c357-4ca9-9d6f-f5a26cafdff3/image.png\" alt=\"드래그2\"></p>\n<p>JENNIFER Front에서 사용하는 추적옵션은 다음과 같은 6종류입니다.</p>\n<ul>\n<li>대기</li>\n</ul>\n<blockquote>\n<p>http request 시작 후 Server에서 데이터를 보내기까지 대기시간</p>\n</blockquote>\n<ul>\n<li>Server</li>\n</ul>\n<blockquote>\n<p>Server에서 데이터를 보내는 시간</p>\n</blockquote>\n<ul>\n<li>Network</li>\n</ul>\n<blockquote>\n<p>http request 시작 후 response를 받는 시점까지</p>\n</blockquote>\n<ul>\n<li>Dom</li>\n</ul>\n<blockquote>\n<p>response에서 Dom을 로드 하는 시간</p>\n</blockquote>\n<ul>\n<li>Render</li>\n</ul>\n<blockquote>\n<p>Dom을 로드하고 css/js 등을 통해 페이지를 렌더링하는 시간</p>\n</blockquote>\n<ul>\n<li>로드</li>\n</ul>\n<blockquote>\n<p>렌더링 이후 로드에 소요된 시간</p>\n</blockquote>\n<h1>😣 아.. 뭐야! 둘 다 잘못했네!</h1>\n<p>맞습니다.! 위 화면에서 Network 구간에서 2.3초나 소요되었고 Dom을 로드하고 Render 하는 구간에서 3.7초나 소요되었습니다. 나머지 서버 로딩 지연 등을 포함해 사용자는 웹 페이지를 로딩하는데 9.3초를 소비하게 되었죠 (😱끔찍하네요)</p>\n<p>🤵대표님 : 개발팀 집합....</p>\n<h1>🤩 어떻게 분석하나요?</h1>\n<p>가장 많이 발생되는 지연구간별 원인은 다음과 같습니다.</p>\n<ol>\n<li>Server/Network 구간</li>\n</ol>\n<ul>\n<li>이 두 구간은 브라우저가 html을 받기까지의 구간입니다. Network 시간</li>\n<li>Server 시간을 한다면 순수 전송에 소요된 시간을 알 수 있습니다. 순수 전송에 소요 된 시간이 적다면 Server의 문제로 보입니다. html를 반환하는 과정에서 오래 소요되는 구간을 찾을 필요가 있습니다.</li>\n<li>순수 전송 소요시간이 길다면, Network 구성에 문제가 있을 수 있습니다. CDN 서비스를 사용하거나 캐싱 처리해 최적화 할 필요가 있습니다.</li>\n</ul>\n<ol start=\"2\">\n<li>Dom/Render 구간</li>\n</ol>\n<ul>\n<li>이 두 구간은 브라우저가 html을 받고 Dom을 처리하거나 Rendering 하는 과정의 이슈 구간입니다.</li>\n<li>Dom 구간이 느리다면 Dom이 너무 중첩되거나 무겁지 않은지 확인이 필요합니다.</li>\n<li>Render 구간이 느리다면 Font/Javasciprt/Css등 Rendering 지연 파일들의 Network 전송 이슈는 없었는지 확인합니다. 있었다면 Network 구간의 정비가 필요합니다. 없었다면 원인이 Javasciprt로 인한 것인지 다른 기타요인으로 인한 것인지 확인이 필요합니다.</li>\n<li>타임라인을 내려보면, 파일별로 Rendering을 볼 수 있어, 개별적으로 확인 후 분석이 필요합니다.</li>\n</ul>\n<h1>😓 어렵죠..? 예시로 설명함돠!</h1>\n<h2>🙋‍ CDN을 쓰는데 Network 구간이 느려요</h2>\n<p>정적콘텐츠(Javascript/이미지/CSS/Font 등)의 전송을 빠르게 하고자 CDN(Contents Delivery Network)를 많이 활용하실 텐데요, CDN을 너무 맹신하시면 안 됩니다</p>\n<p>우리는 CDN을 쓰니까 모든 지역에서 빠르겠지?! 는 오해일 수 있습니다.\n지역에 따라 전송이 느린 서비스가 종종 있기 때문이죠!</p>\n<p>JENNIFER Front의 Resource 분석에서는, 각 정적콘텐츠가 지역별로 로딩에 어느 정도 소요되었는지 볼 수 있습니다.</p>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/b40ae23e-8f2a-4e7d-9cb5-6dd391c2b830/image.gif\" alt=\"지역별로딩\"></p>\n<p>위처럼 CDN을 사용하더라도 일부 구간에서 로딩이 느릴 수 있습니다.\n🏃‍♀️앗! 팀장님~~!! 우리 CDN 서비스 바꿔요!!!</p>\n<h2>🙋‍♂️ SPA 서비스에서 Ajax로 통신을 하고 있어요</h2>\n<p>SPA(Single Page Application)를 사용하는 경우, html과 Javascript를 먼저 반환하고 데이터는 Ajax를 통해 불러오는 경우가 많은데요!</p>\n<p>Ajax에서 데이터 받는 시간이 길어져 사용자의 입장에서 렌더링이 느리게 느껴질 수 있답니다.!</p>\n<p>아래와 같이 Ajax 통신만 담당하는 담당 일찐 페이지가 따로 있어요!\n시간에 따른 호출수/지연시간/Error 발생 비율 등을 볼 수 있습니다.</p>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/82bef7dc-a02e-43d2-a855-68769447f1a4/image.png\" alt=\"ajax담당\"></p>\n<h2>🙋‍ JS 라이브러리는 외부에서 당겨쓰니까 빠르겠죠?</h2>\n<p>안일한 생각은 NO !\n아래 사진은 '다음' CDN에서 배포하는 이미지 파일에 대한 로그입니다.</p>\n<p>서울특별시에서 평균 4.9초의 응답속도를 보이는 것으로 확인되는데요,\n이런 듯 공신력 있는 CDN 서비스에서 배포하는 파일이라도 방심은 할 수 없습니다!</p>\n<p>서비스 로딩에 지연을 주는 중요한 파일이라면 꼭! 안정적인 CDN서비스를 통해 배포해야 합니다!</p>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/16408823-f9b9-4438-93c0-6648739a90f5/image.png\" alt=\"이미지용 서버\"></p>\n<h2>🙋‍♂️ 우리는 이미지용 서버를 따로 쓰고 있어요!</h2>\n<p>혹시 해당 서버에서 배포하는 정적 파일들은 안전하게 호스팅 되고 있을까요?!</p>\n<p>JENNIFER Front에서는 아래 사진과 같이 정적 컨텐츠들을 url 규칙에 맞게 자동으로 그룹화하여 url 그룹 별 통계를 제공합니다.</p>\n<p>아래 사진을 보면, 호출이 몰리는 일부 구간에서 다운로드 시간이 평균 0.27초에서 0.54초 속도가 튀는게 보이시죠?!</p>\n<p>0.54초가 짧게 보일 수 있지만, 게시물을 예로 들면 한 게시물 내에 수십개의 이미지가 첨부될 수 있기 때문에 짧지만은 않은 지연시간입니다.!</p>\n<blockquote>\n<p>😱 이미지 서버뿐 아니에요!\n우리가 자주 사용하는 파일용서버/스트리밍용 서버 등에서도\n비슷한 경우가 자주 발생한답니다!\n각 url 그룹별로 지연원인은 없는지 자주 분석하는게 좋아요!</p>\n</blockquote>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/3c9236c0-052d-41b3-a784-9ddd917b885c/image.png\" alt=\"웹폰트\"></p>\n<h2>🙋‍ 당신의 웹 폰트는 안녕하신가요?</h2>\n<p>여러분들께서 사용하시는 웹 폰트는 안녕하신가요?\n국내에서 많이 사용하는 NotoSansKR, 나눔고딕 등의 폰트는 사실 매우 무겁습니다.</p>\n<p>로딩하고 랜더링하는데에 2초 가량이 소요되죠!</p>\n<p>때문에 웹 폰트를 항상 경량화 하고 랜더링을 비동기로 처리하는 것이 중요합니다.!</p>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/02bd846e-1413-48cf-a62d-325b0f6b2381/image.png\" alt=\"경량화\"></p>\n<p>웹폰트 최적화와 경량화에 대해 자세히 소개한 게시물을 알려드릴게요!</p>\n<ul>\n<li><a href=\"https://d2.naver.com/helloworld/4969726\">웹 폰트 사용과 최적화의 최근 동향 (Naver D2)</a></li>\n<li><a href=\"http://indivdot.github.io/%EC%9B%B9/2016/04/02/webfont.html\">웹 폰트 경량화 (INDIV.BLOG)</a></li>\n<li><a href=\"https://web-atelier.tistory.com/43\">웹폰트 올바른 방법으로 로딩하자 (웹아틀리에)</a></li>\n</ul>\n<h1>😳 뜻밖의 꿀팁!</h1>\n<p>Javascript Error 분석기능도 있습니다.!\nJavascript Error가 발생할 경우 수집하여 브라우저 정보 등과 함께 제공합니다.!</p>\n<blockquote>\n<p>😥 왜, 한번씩 그런경우 있잖아요!\n특정 사용자한테만 나타나는 스크립트 에러말이에요!\n이러한 경우에도 console 상에 에러가 발생되면 자동으로 수집된답니다.!</p>\n</blockquote>\n<p><img src=\"https://media.vlpt.us/images/dochis/post/054b17b5-9d7e-43eb-9949-02d3675633d3/image.png\" alt=\"통계\"></p>\n<p>그 이외에도 브라우저 통계, 사용자별 통계, 리소스 그룹별 통계 등 다양한 기능이 있습니다.</p>\n<blockquote>\n<p>사용자별 통계 기능은 해당 사용자가 방문했었던 모든 페이지를 시간순으로 볼 수\n있어요! 디버깅에 활용 할 수 있는 뜻밖의 꿀기능이랍니다.!</p>\n</blockquote>\n<h1>👍 속도개선방법 == 원인제거</h1>\n<p>지금까지 웹 속도를 느리게 하는 다양한 원인을 분석하는 방법을 알아보았습니다.</p>\n<p>웹 서비스의 속도를 개선하는 방법은 이러한 속도를 느리게 하는 문제를 해결하는 데에 있습니다. 지금까지 소개한 내용을 요약해보도록 하겠습니다.</p>\n<h3>&lt; 속도를 개선하는 방법 &gt;</h3>\n<ul>\n<li>서버에서 브라우저의 Request에 더 빠른 반응을 하도록 하고 더 빠른 Response를 반환하도록 개선 (캐싱 등)</li>\n<li>서버에서 반환하는 Response를 빠르게 브라우저에 전달할 수 있도록 Network 구간을 개선 (gzip 등)</li>\n<li>웹 페이지의 랜더링을 지연시키는 요소를 제거 (Javascript 튜닝 등)</li>\n<li>정적 콘텐츠들을 더 빠르고 안정적으로 호스팅할 수 있는 CDN 서비스 선택</li>\n<li>정적 콘텐츠들을 브라우저 스토리지에 캐싱</li>\n<li>정적 콘텐츠 요청시 HTTP/2, HTTP/3 등의 상위 프로토콜 사용추천</li>\n</ul>\n<p>으로 정리해볼 수 있을 것 같습니다.</p>\n<h1>👋 마치며</h1>\n<p>오늘은 APM(Application Performance Management)도구 중 front-end 개발자가 사용하면 좋을 도구에 대해 소개해보았습니다.</p>\n<p><strong>이 멋진 도구는 Javascript 몇 줄을 추가하는 것만으로 쉽게 사용하실 수 있습니다.!</strong></p>\n<p>이렇게 멋진 소프트웨어를 무료로 사용할 수 있다는 점이 정말 좋은 것 같습니다.</p>\n<blockquote>\n<p>ps) 😎 이 게시물을 회사 대표님이 못 보게 하세요.!</p>\n</blockquote>\n<blockquote>\n<p>궁금하신 내용이나 프로그램 사용 중 막히는 부분이 있다면 언제든지 댓글로\n문의하여 주세요.! 댓글은 환영입니다.!</p>\n</blockquote>\n<p>도움을 주신 많은 분들께 감사드립니다.</p>\n<h1>💪 함께 하면 좋을 링크</h1>\n<p><a href=\"https://blog.dochis.net/2020/09/06/Ways-to-Monitor-Service-for-Free.html?utm_source=velog&amp;utm_medium=post&amp;utm_campaign=399f85b4-8680-40c9-8c38-becfe3794eb2\">무료로 서비스를 모니터링하는 3가지 방법</a></p>\n<p><a href=\"https://front.jennifersoft.com/about/ko/\">제니퍼 프론트 사이트</a></p>\n<p><a href=\"https://jennifersoft.com/ko/\">제니퍼소프트 사이트</a></p>\n",
  "__v": 0
},{
  "_id": {
    "$oid": "5f682b3b5afb8d087c7c2841"
  },
  "createdAt": {
    "$date": "2020-09-21T02:29:20.071Z"
  },
  "title": "JS스럽게 좋은 코드 쓰기 꿀팁",
  "user": "tamd5971@naver.com",
  "markdown": "[원글 링크](https://velog.io/@wooder2050/JS%EC%8A%A4%EB%9F%BD%EA%B2%8C-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C-%EC%93%B0%EA%B8%B0-%EA%BF%80%ED%8C%81)\r\n\r\n![JS](https://media.vlpt.us/images/wooder2050/post/eb9f8886-3466-44c7-bc01-eb73c2c58645/0_ah8yui7nqaz6b-v_.png)\r\n\r\n# 1. 비구조화 할당(Destructuring)\r\n\r\n![자동차 객체](https://media.vlpt.us/images/wooder2050/post/d892f88e-030b-44a7-a7cd-b5bd298e51e9/1%20(2).png)\r\n\r\n자동차를 나타내는 객체를 만들었다. driving이라는 함수를 만들어 자동차의 이름은 무엇이고 몇 초만에 최고 속도 몇까지 올라가지는 나타내도록 해보자.\r\n\r\n## 똥 코드 💩\r\n\r\n![car!](https://media.vlpt.us/images/wooder2050/post/3cc0c0ed-fcb6-4b5b-a0f0-ace26de819d4/2.png)\r\n\r\ncar 객체를 매개변수로 받아서 diving1 함수에서 name, zeroBack, maximumSpeed를 활용하고 있다. 이 방식은 그렇게 나쁜 방식은 아니지만 car. 부분이 계속해서 반복되고 있다.\r\n\r\n## JS스러운 코드 ✔️\r\n\r\n비구조화 할당은 이용하면 반복되는 car. 부분을 없앨 수 있다.\r\n\r\n![2](https://media.vlpt.us/images/wooder2050/post/189112c3-3637-4927-8604-91f36c61763a/3.png)\r\n\r\n매개변수 단계에서 비구조화 할당을 하는 방법과 함수 안에 비구조화 할당을 하는 방법이 있다. 두 가지 방법은 사용하는 객체의 크기나 함수의 상황에 따라 선택해서 사용하면 된다.\r\n\r\n# 2. 템플릿 리터럴(Template literal)\r\n\r\n![3](https://media.vlpt.us/images/wooder2050/post/2ce3d7b3-38a9-494d-a958-9d41377edc68/4%20(2).png)\r\n\r\nteslaModel3를 나타내는 문자열을 만들어보자.\r\n\r\n## String 똥 코드 💩\r\n\r\n![4](https://media.vlpt.us/images/wooder2050/post/f3e427cc-80d7-4e4b-82e4-d36640025014/5%20(2).png)\r\n\r\n템플릿 리터럴을 사용하기 이전에는 이런식으로 문자열을 만들었다. 띄어쓰기와 변수 사이에 항상 +를 신경써야 했다.\r\n\r\n## JS스러운 String 코드 ✔️\r\n\r\n$ 과 backtick 키(숫자 1 키 왼쪽에 있는 키)를 이용하면 문장을 쓰듯이 문자열을 만들 수 있다. 위의 코드에 비해 읽기도 쓰고 유지, 보수하기도 편하다.\r\n\r\n![5](https://media.vlpt.us/images/wooder2050/post/12d323f1-db2a-4923-a5e9-c996e9d381f6/7.png)\r\n\r\n텀플릿 리터럴은 함수의 매개변수로도 사용할 수 있다. () 대신 backtick 키를 사용해 매개변수를 전달하고 문자열과 변수로 구분해서 받을 수 있다. 위의 함수에서는 str로 문자열을 받고 price로 teslaModel3.price를 받아 사용했다.\r\n\r\n# 3. spread 연산자 (Spread syntax)\r\n\r\n![6](https://media.vlpt.us/images/wooder2050/post/62fff362-2ef5-4321-b9b1-bccb0259e676/8%20(2).png)\r\n\r\n엘런 머스크 객체 안에 엘런 머스크의 회사 가치를 더 해보자.\r\n\r\n## Object 똥 코드 💩\r\n\r\n두 객체를 병합할 때 첫번째 방식과 같이 하나씩 속성을 만들어 삽입하는 방식이 있다. 이 방식은 객체의 속성이 많아질수록 작성하기 힘들어진다. 그래서 두번째에서는 Object.assign을 이용했다. 만약 엘런 머스크의 회사 가치를 연도별로 정리한다면 위에 첫번째 방식으로 코드를 작성하기 힘들 것이다. 두번째 방식으로는 쉽게 작성할 수 있다.\r\n\r\n## JS스러운 Object 코드 ✔️\r\n\r\n![7](https://media.vlpt.us/images/wooder2050/post/81ddbf23-f7ef-45c1-8550-c453c2ce1f65/10%20(2).png)\r\n\r\nObject.assign 방식은 그렇게 나쁜 방식은 아니지만 spread 연산자를 사용하면 위에처럼 더 간단하게 코드를 작성할 수 있다.\r\n\r\n## Array\r\nspread 연산자는 배열에서도 마찬가지로 사용 가능하다.\r\n\r\n![8](https://media.vlpt.us/images/wooder2050/post/f640a909-64c4-414a-98b9-8172cb389cf7/11.png)\r\n\r\nFAANG에 빠진 나머지 기업들을 배열에 추가해보자.\r\n\r\n## Array 똥 코드 💩\r\n\r\n이렇게 배열 요소 하나하나를 push로 밀어넣는 방식은 배열 요소가 많아진다면 유지,보수하기 힘들어진다.\r\n\r\n## JS스러운 Array 코드 ✔️\r\n\r\n![9](https://media.vlpt.us/images/wooder2050/post/81c19a96-df3a-489f-a781-cf211dd767f9/13.png)\r\n\r\nspread 연산자를 사용하면 코드는 더 간결해지고 배열 조작은 더 쉬워진다. 맨 앞과 맨 뒤 뿐만 아니라 어느 위치로도 기존 배열의 위치를 조정할 수 있다.\r\n\r\n# 4. 반복하기(Loops)\r\n\r\n![10](https://media.vlpt.us/images/wooder2050/post/767f6123-8add-40cf-a8e5-43ee2eefff18/14%20(2).png)\r\n\r\n장바구니에 담긴 종목들의 총합과 수수료를 포함한 가격이 나타내는 배열 그리고 1500 달러보다 비싼 종목들의 배열을 만들어보자.\r\n\r\n## Loop 똥 코드 💩\r\n\r\n![11](https://media.vlpt.us/images/wooder2050/post/a3285f9d-8022-4933-8ca2-ee98cc4ff638/15.png)\r\n\r\n위의 코드는 for문을 돌면서 총합을 나타내는 total과 수수료를 더한 가격인 withFree 그리고 높은 가격의 종목를 따로 구분한 highPrice의 값을 구분했다. 이 코드는 문제는 없지만 코드를 보면서 바로 이해하기 힘들며 예측하기 어렵다.\r\n\r\n## JS스러운 Loop 코드 ✔️\r\n\r\n![12](https://media.vlpt.us/images/wooder2050/post/1616361f-5c42-42ab-bcb1-d2cbfa2b630e/16.png)\r\n\r\n이 코드는 total, withFee, highPrice가 명확히 구분되어 있고 한 줄로 체이닝되어 있어서 빠르게 이해할 수 있다. 자바스크립트에선 보통 이렇게 함수형으로 작성을 많이 한다.\r\n\r\n# 5. async/await\r\n\r\n![13](https://media.vlpt.us/images/wooder2050/post/6f098962-66c6-4d1e-a598-bdd7f41ff0d2/17.png)\r\n\r\n랜덤으로 숫자를 만들어주는 promise객체를 리턴하는 함수를 만들었다. 세 숫자를 랜덤하게 만든 후에 그 세 숫자의 합을 console.log로 찍어주는 함수를 만들어보자.\r\n\r\n## Promise 똥 코드 💩\r\n\r\n![14](https://media.vlpt.us/images/wooder2050/post/b61cda3c-7c2d-44c0-a913-f9d86ba03340/18.png)\r\n\r\npromise와 then을 이용해서 숫자 세 개를 받아 합을 나타내는 함수를 만들었다. 이 코드는 then,then,then,then ... 숫자가 많아질수록 읽기 힘든 코드가 될 것이다.\r\n\r\n## JS스러운 Promis 코드 ✔️\r\n\r\n![15](https://media.vlpt.us/images/wooder2050/post/d7d3f129-b754-4135-8024-46e7183a6957/19.png)\r\n\r\nasync/await를 사용하면 동기로 된 코드처럼 한줄 한줄 순서대로 작성된 코드를 작성할 수 있다. 가독성도 좋고 더 이상 then,then 으로 꼬리를 물면서 코드를 작성할 필요가 없다.\r\n\r\n",
  "makrdownHtml": "<p><a href=\"https://velog.io/@wooder2050/JS%EC%8A%A4%EB%9F%BD%EA%B2%8C-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C-%EC%93%B0%EA%B8%B0-%EA%BF%80%ED%8C%81\">원글 링크</a></p>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/eb9f8886-3466-44c7-bc01-eb73c2c58645/0_ah8yui7nqaz6b-v_.png\" alt=\"JS\"></p>\n<h1>1. 비구조화 할당(Destructuring)</h1>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/d892f88e-030b-44a7-a7cd-b5bd298e51e9/1%20(2).png\" alt=\"자동차 객체\"></p>\n<p>자동차를 나타내는 객체를 만들었다. driving이라는 함수를 만들어 자동차의 이름은 무엇이고 몇 초만에 최고 속도 몇까지 올라가지는 나타내도록 해보자.</p>\n<h2>똥 코드 💩</h2>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/3cc0c0ed-fcb6-4b5b-a0f0-ace26de819d4/2.png\" alt=\"car!\"></p>\n<p>car 객체를 매개변수로 받아서 diving1 함수에서 name, zeroBack, maximumSpeed를 활용하고 있다. 이 방식은 그렇게 나쁜 방식은 아니지만 car. 부분이 계속해서 반복되고 있다.</p>\n<h2>JS스러운 코드 ✔️</h2>\n<p>비구조화 할당은 이용하면 반복되는 car. 부분을 없앨 수 있다.</p>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/189112c3-3637-4927-8604-91f36c61763a/3.png\" alt=\"2\"></p>\n<p>매개변수 단계에서 비구조화 할당을 하는 방법과 함수 안에 비구조화 할당을 하는 방법이 있다. 두 가지 방법은 사용하는 객체의 크기나 함수의 상황에 따라 선택해서 사용하면 된다.</p>\n<h1>2. 템플릿 리터럴(Template literal)</h1>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/2ce3d7b3-38a9-494d-a958-9d41377edc68/4%20(2).png\" alt=\"3\"></p>\n<p>teslaModel3를 나타내는 문자열을 만들어보자.</p>\n<h2>String 똥 코드 💩</h2>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/f3e427cc-80d7-4e4b-82e4-d36640025014/5%20(2).png\" alt=\"4\"></p>\n<p>템플릿 리터럴을 사용하기 이전에는 이런식으로 문자열을 만들었다. 띄어쓰기와 변수 사이에 항상 +를 신경써야 했다.</p>\n<h2>JS스러운 String 코드 ✔️</h2>\n<p>$ 과 backtick 키(숫자 1 키 왼쪽에 있는 키)를 이용하면 문장을 쓰듯이 문자열을 만들 수 있다. 위의 코드에 비해 읽기도 쓰고 유지, 보수하기도 편하다.</p>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/12d323f1-db2a-4923-a5e9-c996e9d381f6/7.png\" alt=\"5\"></p>\n<p>텀플릿 리터럴은 함수의 매개변수로도 사용할 수 있다. () 대신 backtick 키를 사용해 매개변수를 전달하고 문자열과 변수로 구분해서 받을 수 있다. 위의 함수에서는 str로 문자열을 받고 price로 teslaModel3.price를 받아 사용했다.</p>\n<h1>3. spread 연산자 (Spread syntax)</h1>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/62fff362-2ef5-4321-b9b1-bccb0259e676/8%20(2).png\" alt=\"6\"></p>\n<p>엘런 머스크 객체 안에 엘런 머스크의 회사 가치를 더 해보자.</p>\n<h2>Object 똥 코드 💩</h2>\n<p>두 객체를 병합할 때 첫번째 방식과 같이 하나씩 속성을 만들어 삽입하는 방식이 있다. 이 방식은 객체의 속성이 많아질수록 작성하기 힘들어진다. 그래서 두번째에서는 Object.assign을 이용했다. 만약 엘런 머스크의 회사 가치를 연도별로 정리한다면 위에 첫번째 방식으로 코드를 작성하기 힘들 것이다. 두번째 방식으로는 쉽게 작성할 수 있다.</p>\n<h2>JS스러운 Object 코드 ✔️</h2>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/81ddbf23-f7ef-45c1-8550-c453c2ce1f65/10%20(2).png\" alt=\"7\"></p>\n<p>Object.assign 방식은 그렇게 나쁜 방식은 아니지만 spread 연산자를 사용하면 위에처럼 더 간단하게 코드를 작성할 수 있다.</p>\n<h2>Array</h2>\n<p>spread 연산자는 배열에서도 마찬가지로 사용 가능하다.</p>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/f640a909-64c4-414a-98b9-8172cb389cf7/11.png\" alt=\"8\"></p>\n<p>FAANG에 빠진 나머지 기업들을 배열에 추가해보자.</p>\n<h2>Array 똥 코드 💩</h2>\n<p>이렇게 배열 요소 하나하나를 push로 밀어넣는 방식은 배열 요소가 많아진다면 유지,보수하기 힘들어진다.</p>\n<h2>JS스러운 Array 코드 ✔️</h2>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/81c19a96-df3a-489f-a781-cf211dd767f9/13.png\" alt=\"9\"></p>\n<p>spread 연산자를 사용하면 코드는 더 간결해지고 배열 조작은 더 쉬워진다. 맨 앞과 맨 뒤 뿐만 아니라 어느 위치로도 기존 배열의 위치를 조정할 수 있다.</p>\n<h1>4. 반복하기(Loops)</h1>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/767f6123-8add-40cf-a8e5-43ee2eefff18/14%20(2).png\" alt=\"10\"></p>\n<p>장바구니에 담긴 종목들의 총합과 수수료를 포함한 가격이 나타내는 배열 그리고 1500 달러보다 비싼 종목들의 배열을 만들어보자.</p>\n<h2>Loop 똥 코드 💩</h2>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/a3285f9d-8022-4933-8ca2-ee98cc4ff638/15.png\" alt=\"11\"></p>\n<p>위의 코드는 for문을 돌면서 총합을 나타내는 total과 수수료를 더한 가격인 withFree 그리고 높은 가격의 종목를 따로 구분한 highPrice의 값을 구분했다. 이 코드는 문제는 없지만 코드를 보면서 바로 이해하기 힘들며 예측하기 어렵다.</p>\n<h2>JS스러운 Loop 코드 ✔️</h2>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/1616361f-5c42-42ab-bcb1-d2cbfa2b630e/16.png\" alt=\"12\"></p>\n<p>이 코드는 total, withFee, highPrice가 명확히 구분되어 있고 한 줄로 체이닝되어 있어서 빠르게 이해할 수 있다. 자바스크립트에선 보통 이렇게 함수형으로 작성을 많이 한다.</p>\n<h1>5. async/await</h1>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/6f098962-66c6-4d1e-a598-bdd7f41ff0d2/17.png\" alt=\"13\"></p>\n<p>랜덤으로 숫자를 만들어주는 promise객체를 리턴하는 함수를 만들었다. 세 숫자를 랜덤하게 만든 후에 그 세 숫자의 합을 console.log로 찍어주는 함수를 만들어보자.</p>\n<h2>Promise 똥 코드 💩</h2>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/b61cda3c-7c2d-44c0-a913-f9d86ba03340/18.png\" alt=\"14\"></p>\n<p>promise와 then을 이용해서 숫자 세 개를 받아 합을 나타내는 함수를 만들었다. 이 코드는 then,then,then,then ... 숫자가 많아질수록 읽기 힘든 코드가 될 것이다.</p>\n<h2>JS스러운 Promis 코드 ✔️</h2>\n<p><img src=\"https://media.vlpt.us/images/wooder2050/post/d7d3f129-b754-4135-8024-46e7183a6957/19.png\" alt=\"15\"></p>\n<p>async/await를 사용하면 동기로 된 코드처럼 한줄 한줄 순서대로 작성된 코드를 작성할 수 있다. 가독성도 좋고 더 이상 then,then 으로 꼬리를 물면서 코드를 작성할 필요가 없다.</p>\n",
  "__v": 0
},{
  "_id": {
    "$oid": "5f6830105afb8d087c7c2845"
  },
  "createdAt": {
    "$date": "2020-09-21T02:29:20.071Z"
  },
  "title": "어중간히 알면 안되는 JS 개념 #1 this",
  "user": "tamd5971@naver.com",
  "markdown": "[원글 링크](https://velog.io/@wlsdud2194/%EC%96%B4%EC%A4%91%EA%B0%84%ED%9E%88-%EC%95%8C%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-JS-%EA%B0%9C%EB%85%90-1-this)\r\n\r\n![JS](https://media.vlpt.us/images/wlsdud2194/post/ed3856c9-8f86-4237-9779-5482a1e67125/%EC%8D%B8%EB%84%AC.png)\r\n\r\n자바스크립트를 통해 개발하다보면 가끔보게되는 키워드가 있는 데, 바로 this라는 녀셕입니다.\r\n\r\n\"this? 대충 이렇게 작동하는 녀석아닌가??\" 하고 지나칠 수 있지만, 정확히 알고 적절하게 활용한다면 더욱 깔끔하고 디버깅이 편한 코드를 작성할 수 있을 것입니다.\r\n\r\n# 일단 this를 찍어보자\r\nF12키를 눌러 console에서 this를 한번 찍어봅시다. 그러면 아래와 같은 값이 나올 것 입니다.\r\n```\r\n> this\r\n> Window {\r\napplicationCache: ApplicationCache {status: 0,\r\nLocalNTP: ƒ LocalNTP()\r\nalert: ƒ alert() oncached: null…}\r\nassert: ƒ assert(condition, opt_message)\r\nassertInstanceof: ƒ assertInstanceof(value, type, opt_message)\r\n...\r\n}\r\n```\r\n네, **Window 객체**가 나옵니다. Window 객체는 일반적으로 브라우저의 요소와 자바스크립트 엔진과 관련된 모든 정보를 포함하고 있는 객체입니다.\r\n\r\n하지만 단순히 this = Window 객체 라면, 이 글을 쓰지 않았겠죠?\r\n\r\n# 문법에 따라 this가 바뀐다?.\r\n\r\n전에 커뮤니티에 이런 글이 하나 올라왔었습니다.\r\n\r\n> Q . function 과 () => {} (화살표 함수)의 차이점이 무엇인가요?\r\n> \r\n> A : \"this가 달라요\"\r\n> B : \"function은 this를 가지고, 화살표함수는 this를 가지지 않아요\"\r\n\r\n틀린 답변은 아니지만, 정확히 어떻게 this가 다르다는 걸까요?\r\n\r\n입문자 분들이 말 뜻대로 생각했을 때, 아래 코드처럼 생각할 지도 모르죠.\r\n\r\n```javascript\r\n// 서로 다른 값이 출력??\r\nfunction normalFunc() {\r\n  console.log(this); \r\n}\r\n\r\nconst arrowFunc = () => {\r\n  console.log(this);\r\n}\r\n```\r\n\r\n\"function은 this를 가지니까 자기자신 즉 normalFunc를 가리키고, 화살표함수는 this를 안가지니까 Window 함수를 가지겠구나?\" 라고 생각할 수 있지만, 출력해보시면 둘 다 **Window 객체**를 출력하는 것을 알 수 있습니다.\r\n\r\n그럼 대체 뭐가 다른걸까요? 이글을 다 읽고 나시면 알게 되실 겁니다. ㅋㅋ\r\n\r\n우선 **실행 컨텍스트**라는 개념을 알아야 합니다.\r\n\r\n# 실행 컨텍스트(Execution Context)\r\n\r\n**실행 컨텍스트**란 자바스크립트 코드가 실행되고 연산되는 범위를 나타내는 추상적인 개념으로 코드가 실행된다면 실행 컨텍스트 내부에서 작동하고 있는 것이라고 보면 됩니다.\r\n\r\n실행 컨텍스트는 크게 3가지로 분류되는 데, 메인 주제가 아니므로 주요한 2가지만 간단하게 알아보겠습니다. (자세한 내용은 구글에...)\r\n\r\n### Global Execution Context\r\n기본적으로 코드가 실행되는 영역이며, 여기서 글로벌 객체인 Window 객체를 생성하며, this를 글로벌 객체(Window 객체)로 설정해줍니다.\r\n\r\n그래서 아까 this를 찍었을 때, Window 객체가 출력된 것이죠.\r\n\r\n### Functional Execution Context\r\n각각의 함수가 가지는 실행 컨텍스트로, 함수가 호출될 때 해당 실행 컨텍스트 생성이 됩니다.\r\n\r\n![1](https://media.vlpt.us/images/wlsdud2194/post/3c06a902-bf11-4d82-8e0a-2952f7113f64/example.png)\r\n\r\n# 언제 this가 바뀔까\r\nthis는 기본적으로 Window 객체를 말합니다(Node.js는 Global 객체).\r\n\r\n하지만 this의 값이 바뀌는 경우가 있습니다. 때문에 this 값이 어떻게 바뀌고 있는지, 해당 this가 무슨 값인지 알기 위해선 코드의 문맥을 살펴볼 필요가 있습니다.\r\n\r\n## 객체의 메소드를 호출하는 경우\r\n```javascript\r\nconst myObj = {\r\n  myValue: 6,\r\n  myWindow: this,\r\n  myFunc: function() {\r\n    console.log(this);\r\n  },\r\n  myArrow: () => {\r\n    console.log(this);\r\n  },\r\n};\r\n\r\nconsole.log(myObj.myFunc()); // Window 객체\r\nconsole.log(myObj.myArrow()); // myObj 객체\r\n```\r\n\r\n출력되는 this의 값이 바뀌었나요? MDN에는 아래와 같이 설명하고 있습니다.\r\n\r\n> + 함수를 어떤 객체의 메소드로 호출하면 this의 값은 그 객체를 사용합니다.\r\n> + ES2015는 스스로의 this 바인딩을 제공하지 않는 화살표 함수를 추가했습니다.\r\n> -MDN web docs-\r\n\r\n이것이 아까 위에서 나왔던 답변의 정확한 의미입니다. function 키워드는 해당 객체를 바인딩하여 this의 값을 변경하는 것이고, () => {}는 상위 객체의 this를 그대로 이어받아(?) 사용하는 것입니다.\r\n\r\n## 생성자를 통해 객체를 생성하는 경우\r\n```javascript\r\nfunction Programmer(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\n\r\n// 생성자를 사용하지 않은 경우 - 단순 호출\r\nconst covy = Programmer('Covy', 20); // covy 변수는 undefined\r\nconsole.log(window.name, window.age); // Covy 20\r\n\r\n// 생성자를 통한 객체 생성\r\nconst tony = new Programmer('Tony', 25);\r\nconsole.log(tony.name, tony.age); // Tony 25 - this가 해당 객체에 바인딩됨\r\n```\r\n\r\nnew 키워드를 통해 객채를 생성하면, this가 해당 객체에 바인딩 되어 해당 값을 읽게 되는 것입니다. es6에 추가된 class를 사용하면 동일하게 작동하는 것을 볼 수 있습니다.\r\n\r\n## 예외적인 경우\r\nJquery, React 등에 일부 라이브러리에서 엘리먼트에 이벤트를 추가할 때, 콜백함수에서 this를 사용하면 값이 바뀌는 경우가 있습니다.\r\n\r\n아래 코드를 봐주세요\r\n\r\n```javascript\r\n// Jquery\r\n$('div').on('click', function() {\r\n  console.log(this); // <div>\r\n  function normalFunc() {\r\n    console.log(this); // Window 객체\r\n  }\r\n  const arrowFunc = () => {\r\n    console.log(this); // <div>\r\n  }\r\n});\r\n```\r\n\r\n위 코드처럼 라이브러리 상에서 this를 바인딩 해주는 경우가 있기도하니 this를 사용할 때는 해당 라이브러리의 document를 찾아보는 것도 중요할 것입니다. (아니면 stack overflow)\r\n\r\n# apply(), call(), bind() ?\r\n사실 this는 이 3개를 이해하기 위한 발판입니다. 자바스크립트에서는 this를 자유자제로 바꿀 수 있도록 해주는 메소드를 제공하는 데, 바로 apply, call, bind 입니다.\r\n\r\n> ES5는 함수를 어떻게 호출했는지 상관하지 않고 this 값을 설정할 수 있는 bind 메서드를 도입했습니다.\r\n\r\n> -MDN web docs-\r\n\r\n```javascript\r\nconst Tom = {\r\n  age: 25,\r\n  gender: 'man',\r\n};\r\n\r\nfunction printProfile(name) {\r\n  console.log(name, this.age, this.gender);\r\n}\r\n\r\nprintProfile.apply(Tom, ['Tom']); // Tom 25 man\r\nprintProfile.call(Tom, 'Tom'); // Tom 25 man\r\nprintProfile.bind(Tom, 'Tom').call(); // Tom 25 man\r\n```\r\n\r\n+ apply : call 함수와 유사하지만, 매개변수는 배열로 받는것에 있어 차이가 있다.\r\n+ call : 객채를 바인딩 함과 동시에 호출을 한다.\r\n+ bind : 바인딩이된 함수를 반환하며, 한번더 호출시 함수를 실행한다.\r\n\r\n# 마치며\r\n사실 자바스크립트로 개발하면서 this를 보게될 일은 적습니다. 하지만 모르고 코드를 쓰는 것보다. 알고 더욱 좋은 코드로 발전 시키는 것에는 분명한 차이가 있을 것입니다.\r\n\r\n+) 글의 오류, 오타가 있다면 언제든 댓글을 남겨주세요 😀",
  "makrdownHtml": "<p><a href=\"https://velog.io/@wlsdud2194/%EC%96%B4%EC%A4%91%EA%B0%84%ED%9E%88-%EC%95%8C%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-JS-%EA%B0%9C%EB%85%90-1-this\">원글 링크</a></p>\n<p><img src=\"https://media.vlpt.us/images/wlsdud2194/post/ed3856c9-8f86-4237-9779-5482a1e67125/%EC%8D%B8%EB%84%AC.png\" alt=\"JS\"></p>\n<p>자바스크립트를 통해 개발하다보면 가끔보게되는 키워드가 있는 데, 바로 this라는 녀셕입니다.</p>\n<p>&quot;this? 대충 이렇게 작동하는 녀석아닌가??&quot; 하고 지나칠 수 있지만, 정확히 알고 적절하게 활용한다면 더욱 깔끔하고 디버깅이 편한 코드를 작성할 수 있을 것입니다.</p>\n<h1>일단 this를 찍어보자</h1>\n<p>F12키를 눌러 console에서 this를 한번 찍어봅시다. 그러면 아래와 같은 값이 나올 것 입니다.</p>\n<pre class=\"hljs\"><code>&gt; this\n&gt; Window {\napplicationCache: ApplicationCache {status: 0,\nLocalNTP: ƒ LocalNTP()\nalert: ƒ alert() oncached: null…}\nassert: ƒ assert(condition, opt_message)\nassertInstanceof: ƒ assertInstanceof(value, type, opt_message)\n...\n}\n</code></pre>\n<p>네, <strong>Window 객체</strong>가 나옵니다. Window 객체는 일반적으로 브라우저의 요소와 자바스크립트 엔진과 관련된 모든 정보를 포함하고 있는 객체입니다.</p>\n<p>하지만 단순히 this = Window 객체 라면, 이 글을 쓰지 않았겠죠?</p>\n<h1>문법에 따라 this가 바뀐다?.</h1>\n<p>전에 커뮤니티에 이런 글이 하나 올라왔었습니다.</p>\n<blockquote>\n<p>Q . function 과 () =&gt; {} (화살표 함수)의 차이점이 무엇인가요?</p>\n<p>A : &quot;this가 달라요&quot;\nB : &quot;function은 this를 가지고, 화살표함수는 this를 가지지 않아요&quot;</p>\n</blockquote>\n<p>틀린 답변은 아니지만, 정확히 어떻게 this가 다르다는 걸까요?</p>\n<p>입문자 분들이 말 뜻대로 생각했을 때, 아래 코드처럼 생각할 지도 모르죠.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 서로 다른 값이 출력??</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">normalFunc</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>); \n}\n\n<span class=\"hljs-keyword\">const</span> arrowFunc = <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);\n}\n</code></pre>\n<p>&quot;function은 this를 가지니까 자기자신 즉 normalFunc를 가리키고, 화살표함수는 this를 안가지니까 Window 함수를 가지겠구나?&quot; 라고 생각할 수 있지만, 출력해보시면 둘 다 <strong>Window 객체</strong>를 출력하는 것을 알 수 있습니다.</p>\n<p>그럼 대체 뭐가 다른걸까요? 이글을 다 읽고 나시면 알게 되실 겁니다. ㅋㅋ</p>\n<p>우선 <strong>실행 컨텍스트</strong>라는 개념을 알아야 합니다.</p>\n<h1>실행 컨텍스트(Execution Context)</h1>\n<p><strong>실행 컨텍스트</strong>란 자바스크립트 코드가 실행되고 연산되는 범위를 나타내는 추상적인 개념으로 코드가 실행된다면 실행 컨텍스트 내부에서 작동하고 있는 것이라고 보면 됩니다.</p>\n<p>실행 컨텍스트는 크게 3가지로 분류되는 데, 메인 주제가 아니므로 주요한 2가지만 간단하게 알아보겠습니다. (자세한 내용은 구글에...)</p>\n<h3>Global Execution Context</h3>\n<p>기본적으로 코드가 실행되는 영역이며, 여기서 글로벌 객체인 Window 객체를 생성하며, this를 글로벌 객체(Window 객체)로 설정해줍니다.</p>\n<p>그래서 아까 this를 찍었을 때, Window 객체가 출력된 것이죠.</p>\n<h3>Functional Execution Context</h3>\n<p>각각의 함수가 가지는 실행 컨텍스트로, 함수가 호출될 때 해당 실행 컨텍스트 생성이 됩니다.</p>\n<p><img src=\"https://media.vlpt.us/images/wlsdud2194/post/3c06a902-bf11-4d82-8e0a-2952f7113f64/example.png\" alt=\"1\"></p>\n<h1>언제 this가 바뀔까</h1>\n<p>this는 기본적으로 Window 객체를 말합니다(Node.js는 Global 객체).</p>\n<p>하지만 this의 값이 바뀌는 경우가 있습니다. 때문에 this 값이 어떻게 바뀌고 있는지, 해당 this가 무슨 값인지 알기 위해선 코드의 문맥을 살펴볼 필요가 있습니다.</p>\n<h2>객체의 메소드를 호출하는 경우</h2>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> myObj = {\n  <span class=\"hljs-attr\">myValue</span>: <span class=\"hljs-number\">6</span>,\n  <span class=\"hljs-attr\">myWindow</span>: <span class=\"hljs-built_in\">this</span>,\n  <span class=\"hljs-attr\">myFunc</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);\n  },\n  <span class=\"hljs-attr\">myArrow</span>: <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);\n  },\n};\n\n<span class=\"hljs-built_in\">console</span>.log(myObj.myFunc()); <span class=\"hljs-comment\">// Window 객체</span>\n<span class=\"hljs-built_in\">console</span>.log(myObj.myArrow()); <span class=\"hljs-comment\">// myObj 객체</span>\n</code></pre>\n<p>출력되는 this의 값이 바뀌었나요? MDN에는 아래와 같이 설명하고 있습니다.</p>\n<blockquote>\n<ul>\n<li>함수를 어떤 객체의 메소드로 호출하면 this의 값은 그 객체를 사용합니다.</li>\n<li>ES2015는 스스로의 this 바인딩을 제공하지 않는 화살표 함수를 추가했습니다.\n-MDN web docs-</li>\n</ul>\n</blockquote>\n<p>이것이 아까 위에서 나왔던 답변의 정확한 의미입니다. function 키워드는 해당 객체를 바인딩하여 this의 값을 변경하는 것이고, () =&gt; {}는 상위 객체의 this를 그대로 이어받아(?) 사용하는 것입니다.</p>\n<h2>생성자를 통해 객체를 생성하는 경우</h2>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Programmer</span>(<span class=\"hljs-params\">name, age</span>) </span>{\n  <span class=\"hljs-built_in\">this</span>.name = name;\n  <span class=\"hljs-built_in\">this</span>.age = age;\n}\n\n<span class=\"hljs-comment\">// 생성자를 사용하지 않은 경우 - 단순 호출</span>\n<span class=\"hljs-keyword\">const</span> covy = Programmer(<span class=\"hljs-string\">&#x27;Covy&#x27;</span>, <span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">// covy 변수는 undefined</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">window</span>.name, <span class=\"hljs-built_in\">window</span>.age); <span class=\"hljs-comment\">// Covy 20</span>\n\n<span class=\"hljs-comment\">// 생성자를 통한 객체 생성</span>\n<span class=\"hljs-keyword\">const</span> tony = <span class=\"hljs-keyword\">new</span> Programmer(<span class=\"hljs-string\">&#x27;Tony&#x27;</span>, <span class=\"hljs-number\">25</span>);\n<span class=\"hljs-built_in\">console</span>.log(tony.name, tony.age); <span class=\"hljs-comment\">// Tony 25 - this가 해당 객체에 바인딩됨</span>\n</code></pre>\n<p>new 키워드를 통해 객채를 생성하면, this가 해당 객체에 바인딩 되어 해당 값을 읽게 되는 것입니다. es6에 추가된 class를 사용하면 동일하게 작동하는 것을 볼 수 있습니다.</p>\n<h2>예외적인 경우</h2>\n<p>Jquery, React 등에 일부 라이브러리에서 엘리먼트에 이벤트를 추가할 때, 콜백함수에서 this를 사용하면 값이 바뀌는 경우가 있습니다.</p>\n<p>아래 코드를 봐주세요</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Jquery</span>\n$(<span class=\"hljs-string\">&#x27;div&#x27;</span>).on(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>); <span class=\"hljs-comment\">// &lt;div&gt;</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">normalFunc</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>); <span class=\"hljs-comment\">// Window 객체</span>\n  }\n  <span class=\"hljs-keyword\">const</span> arrowFunc = <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>); <span class=\"hljs-comment\">// &lt;div&gt;</span>\n  }\n});\n</code></pre>\n<p>위 코드처럼 라이브러리 상에서 this를 바인딩 해주는 경우가 있기도하니 this를 사용할 때는 해당 라이브러리의 document를 찾아보는 것도 중요할 것입니다. (아니면 stack overflow)</p>\n<h1>apply(), call(), bind() ?</h1>\n<p>사실 this는 이 3개를 이해하기 위한 발판입니다. 자바스크립트에서는 this를 자유자제로 바꿀 수 있도록 해주는 메소드를 제공하는 데, 바로 apply, call, bind 입니다.</p>\n<blockquote>\n<p>ES5는 함수를 어떻게 호출했는지 상관하지 않고 this 값을 설정할 수 있는 bind 메서드를 도입했습니다.</p>\n</blockquote>\n<blockquote>\n<p>-MDN web docs-</p>\n</blockquote>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> Tom = {\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span>,\n  <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;man&#x27;</span>,\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">printProfile</span>(<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(name, <span class=\"hljs-built_in\">this</span>.age, <span class=\"hljs-built_in\">this</span>.gender);\n}\n\nprintProfile.apply(Tom, [<span class=\"hljs-string\">&#x27;Tom&#x27;</span>]); <span class=\"hljs-comment\">// Tom 25 man</span>\nprintProfile.call(Tom, <span class=\"hljs-string\">&#x27;Tom&#x27;</span>); <span class=\"hljs-comment\">// Tom 25 man</span>\nprintProfile.bind(Tom, <span class=\"hljs-string\">&#x27;Tom&#x27;</span>).call(); <span class=\"hljs-comment\">// Tom 25 man</span>\n</code></pre>\n<ul>\n<li>apply : call 함수와 유사하지만, 매개변수는 배열로 받는것에 있어 차이가 있다.</li>\n<li>call : 객채를 바인딩 함과 동시에 호출을 한다.</li>\n<li>bind : 바인딩이된 함수를 반환하며, 한번더 호출시 함수를 실행한다.</li>\n</ul>\n<h1>마치며</h1>\n<p>사실 자바스크립트로 개발하면서 this를 보게될 일은 적습니다. 하지만 모르고 코드를 쓰는 것보다. 알고 더욱 좋은 코드로 발전 시키는 것에는 분명한 차이가 있을 것입니다.</p>\n<p>+) 글의 오류, 오타가 있다면 언제든 댓글을 남겨주세요 😀</p>\n",
  "__v": 0
},{
  "_id": {
    "$oid": "5f88a6cb75f87c3f50ed232a"
  },
  "createdAt": {
    "$date": "2020-10-15T19:42:01.471Z"
  },
  "title": "community test",
  "user": "community@naver.com",
  "markdown": "## 확인중입니다.",
  "makrdownHtml": "<h2>확인중입니다.</h2>\n",
  "__v": 0
}]